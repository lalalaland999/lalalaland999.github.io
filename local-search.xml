<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker技术入门与实战</title>
    <link href="/2024/01/18/Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/2024/01/18/Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章：初始Docker与容器"><a href="#第一章：初始Docker与容器" class="headerlink" title="第一章：初始Docker与容器"></a>第一章：初始Docker与容器</h2><p>·如果说主机时代比拼的是单个服务器物理性能（如CPU 主频和内存）的强弱，那么在云时代，最为看重的则是凭借虚拟化技术所构建的集群处理能力。</p><p>·传统来看，虚拟化既可以通过硬件模拟来实现，也可以通过操作系统软件来实现。而容器技术则更为优雅，它充分利用了操作系统本已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。</p><p>·Docker 是基于Go 语言实现的开源容器项目，Docker 的构想是要实现“Build, Ship and Run Any App, Anywhere” ，即通过对应用的封装(Packaging)、分发(Distribution)、部署(Deployment)、运行(Runtime) 生命周期进行管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web 应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。</p><p>·Docker基于Linux容器（Linux Containers，LXC）技术发展而来，容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU 本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化(para-virtualization) 和系统调用替换中的复杂性。</p><p>·可以将Docker容器理解为一种轻量级的沙盒，每个每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机</p><p>·举个简单的例子：假设用户试图基于最常见的LAMP (Linux+Apache+MySQL+PHP) 组合来构建网站。按照传统的做法，首先需要安装Apache 、MySQL 和PHP 以及它们各自运行所依赖的环境；之后分别对它们进行配置（包括创建合适的用户、配置参数等）；经过大量的操作后，还需要进行功能测试，看是否工作正常。更为可怕的是，一旦需要服务器迁移（例如从亚马逊云迁移到其他云），往往需要对每个应用都进行重新部署和调试。</p><p>·Docker 提供了一种更为聪明的方式，通过容器来打包应用、解耦应用和运行平台。这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台</p><p>·Docker的优势：1）更快速的交付和部署；2）更高效的资源利用；3）更轻松的迁移和扩展；4）更简单的更新管理</p><p>·Docker与虚拟机的比较：1）Docker 容器很快，启动和停止可以在秒级实现；2）Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker 容器；3）Docker 通过类似Git 设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新；4）Docker 通过Dockerfile 支持灵活的自动化创建和部署机制，以提高工作效率，并标准化流程</p><p>·Docker容器除了运行其中的应用外，基本不消耗额外的系统资源，在保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行N 个不同的应用就要启用N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而Docker 只需要启动N 个隔离得“很薄的＂容器，并将应用放进容器内即可。应用获得的是接近原生的运行性能。</p><p><img src="/../../../img/docker/image-20240115103231840.png"></p><p>·虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。</p><p>·传统虚拟化方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。</p><h2 id="第二章：核心概念与安装配置"><a href="#第二章：核心概念与安装配置" class="headerlink" title="第二章：核心概念与安装配置"></a>第二章：核心概念与安装配置</h2><p>·Docker镜像：Docker 镜像类似于虚拟机镜像，可以将它理解为一个只读的模板，镜像是创建Docker 容器的基础</p><p>·Docker容器：Docker 容器类似千一个轻量级的沙箱， Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例。它可以启动、开始、停止、删除，而这些容器都是彼此相互隔离、互不可见的（镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层）</p><p>·Docker仓库：Docker仓库类似于代码仓库，是Docker 集中存放镜像文件的场所（类似于Git，当用户创建了自己的镜像之后就可以使用push 命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需要将其从仓库上pull 下来就可以了）</p><p>·Windows环境下安装Docker：<a href="https://blog.csdn.net/yangxiao_hui/article/details/107504733">https://blog.csdn.net/yangxiao_hui/article/details/107504733</a></p><h2 id="第三章：使用Docker镜像"><a href="#第三章：使用Docker镜像" class="headerlink" title="第三章：使用Docker镜像"></a>第三章：使用Docker镜像</h2><p>·Docker运行容器前需要本地存在相应的镜像，如果镜像不存在，Docker会尝试先从默认镜像仓库下载，用户也可以配置使用自定义的镜像仓库</p><p>·使用pull命令从Docker Hub镜像源来下载镜像，命令格式为docker [image] pull name [:tag]，其中name是镜像仓库名称，tag是镜像的标签（往往用于表示版本信息），例如docker pull ubuntu:18.04，不显式指定tag会默认选择latest标签</p><p>·下载镜像到本地后，即可使用该镜像，如利用该镜像创建一个容器，在其中运行bash应用，执行打印“Hello World”命令</p><p>docker run -it ubuntu:18.04 bash          </p><p>echo “Hello World”</p><p>·使用docker images或docker image ls可以列出本地主机上已有镜像的基本信息</p><p>·使用tag命令添加镜像标签：docker tag ubuntu:latest myubuntu:latest</p><p>·使用inspect命令查看详细信息：docker inspect ubuntu:18.04</p><p>·使用history命令查看镜像历史：docker history ubuntu:18.04</p><p>·使用search搜索镜像：docker search –filter&#x3D;stars&#x3D;4 tensorflow</p><p>·使用rmi删除和清理镜像：docker rmi myubuntu:latest</p><p>·使用prune命令来清理镜像</p><p>·创建镜像</p><p>1）基于已有容器创建：docker [container] commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] </p><p>2）基于本地模板导入：docker [image] import [OPTIONS] filelURLl-[REPOSITORY[:TAG]]</p><p>3）基于Dockerfile创建：docker [image] build</p><p>·存出镜像：docker save -o ubuntu_18.04.tar ubuntu:18.04</p><p>·载入镜像：docker load -i ubuntu_18.04.tar</p><p>·上传镜像：docker push user&#x2F;test:latest</p><h2 id="第四章：操作Docker容器"><a href="#第四章：操作Docker容器" class="headerlink" title="第四章：操作Docker容器"></a>第四章：操作Docker容器</h2><p>·容器是镜像的一个运行实例，镜像是静态的只读文件，而容器带有运行时需要的可写文件层</p><p>·新建容器：docker [container] create</p><p>·启动容器：docker [container] start</p><p>·docker [container] run等价于先create，再start</p><p>·查看容器输出：docker [container] logs</p><p>·暂停容器：docker [container] pause CONTAINER [CONTAINER…]</p><p>·终止容器</p><p>docker [container] stop</p><p>docker [container] kill</p><p>·进入容器：attach命令、exec命令</p><p>·删除容器：docker [container] rm</p><p>·导出容器：docker [container] export</p><p>·导入容器：docker [container] import</p><p>·查看容器详情：inspect</p><p>·查看容器内进程：top</p><p>·查看统计信息：stats</p><p>·复制文件：cp</p><p>·查看变更：diff</p><p>·查看端口映射：port</p><p>·更新配置：update</p><h2 id="第五章：访问Docker仓库"><a href="#第五章：访问Docker仓库" class="headerlink" title="第五章：访问Docker仓库"></a>第五章：访问Docker仓库</h2><p>·仓库是集中存放镜像的地方，分为公共仓库和私有仓库</p><p>·Dcoker Hub公共镜像市场</p><p>·第三方镜像市场</p><p>·搭建本地私有仓库</p><h2 id="第六章：Docker数据管理"><a href="#第六章：Docker数据管理" class="headerlink" title="第六章：Docker数据管理"></a>第六章：Docker数据管理</h2><p>·容器中管理数据主要有两种方式：1）数据卷，容器内数据直接映射到本地主机环境；2）数据卷容器，使用特定容器维护数据卷</p><p>·数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器</p><p>·创建数据卷：volume命令</p><p>·绑定数据卷：在创建容器时将主机本地的任意路径挂载到容器内作为数据卷</p><p>·数据卷容器：如果用户需要在多个容器间共享一些持续更新的数据，可以使用数据卷容器。数据间容器也是一个容器，它的目的是专门提供数据卷给其他容器挂载。先创建一个数据卷容器，并且创建一个数据间挂载，然后其他的容器可以挂载数据卷容器中的数据卷，此时三个容器任何一方在该目录的写入，其他容器都可以看到</p><p>·利用数据卷容器来迁移数据</p><h2 id="第七章：端口映射与容器互联"><a href="#第七章：端口映射与容器互联" class="headerlink" title="第七章：端口映射与容器互联"></a>第七章：端口映射与容器互联</h2><p>·在实践中，会碰到需要多个服务组件容器共同协作的情况，需要多个容器之间能够互相访问到对方的服务。Docker除了通过网络访问外，还提供了两个很方便的功能来满足服务访问的基本需求：1）允许映射容器内应用的服务端口到本地宿主主机；2）互联机制实现多个容器通过容器名来快速访问</p><p>·在启动容器时，如果不指定对应参数，在容器外部无法通过网络来访问容器内的网络应用和服务，需要通过-p参数来指定端口映射</p><p>·容器的互联是一种让多个容器中的应用进行快速交互的方式，它会在源和接收容器之间创建连接关系，接收容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址</p><p>·–link参数，相当于在两个互联的容器之间创建了一个虚拟通道，而不用映射它们的端口到宿主主机</p><h2 id="第八章：使用Dockerfile创建镜像"><a href="#第八章：使用Dockerfile创建镜像" class="headerlink" title="第八章：使用Dockerfile创建镜像"></a>第八章：使用Dockerfile创建镜像</h2><p>·Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile来快速创建自定义的镜像</p><p>·Dockerfile由一行行命令语句组成，并且支持#开头的注释行，Dockerfile主体内容分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动时执行指令</p><p>·配置指令：arg、from、label、expose、env、entrypoint、volume、user、workdir、onbuild、stopsignal、healthcheck、shell</p><p>·操作指令：run、cmd、add、copy</p><p>·创建镜像：编写完dockerfile后，可以通过docker [image] build命令来创建镜像</p><p>·选择父镜像</p><p>·使用.dockerignore文件</p><h2 id="第九章：操作系统"><a href="#第九章：操作系统" class="headerlink" title="第九章：操作系统"></a>第九章：操作系统</h2><p>·BusyBox：集成了一百多个最常用Linux命令的精简工具箱，只有不到2MB大小</p><p>docker search busybox</p><p>docker pull busybox:latest</p><p>docker run -it busybox</p><p>·Alpine：面向安全的轻型Linux发行版</p><p>docker run alpine echo ‘123’</p><p>使用run指令直接运行Alpine容器，并指定运行的指令</p><p>·Debian&#x2F;Ubuntu：</p><p>docker search debian</p><p>docker run -it debian bash</p><p>·CentOS&#x2F;Fedora：基于Redhat的Linux发行版</p><p>docker search –filter&#x3D;stars&#x3D;50 centos</p><p>docker run -it centos bash</p><h2 id="第十章：为镜像添加SSH服务"><a href="#第十章：为镜像添加SSH服务" class="headerlink" title="第十章：为镜像添加SSH服务"></a>第十章：为镜像添加SSH服务</h2><p>·基于commit命令创建</p><p>·使用Dockerfile创建</p><h2 id="第十一章：Web服务与应用"><a href="#第十一章：Web服务与应用" class="headerlink" title="第十一章：Web服务与应用"></a>第十一章：Web服务与应用</h2><p>介绍通过Docker来运行常见的Web服务器</p><p>·Apache：高稳定性、商业级别的开源Web服务器</p><p>·Nginx：功能强大的开源反向代理服务器</p><p>·Tomcat</p><p>·Jetty</p><p>·LAMP：Linux-Apache-MySQL-PHP</p><h2 id="第十二章：数据库应用"><a href="#第十二章：数据库应用" class="headerlink" title="第十二章：数据库应用"></a>第十二章：数据库应用</h2><p>·MySQL</p><p>·Oracle Database XE</p><p>·MongoDB</p><p>·Redis</p><p>·Cassandra</p><h2 id="第十三章：分布式处理与大数据平台"><a href="#第十三章：分布式处理与大数据平台" class="headerlink" title="第十三章：分布式处理与大数据平台"></a>第十三章：分布式处理与大数据平台</h2><p>·Hadoop</p><p>·Spark</p><p>·Storm</p><p>·Elasticsearch</p><h2 id="第十四章：编程开发"><a href="#第十四章：编程开发" class="headerlink" title="第十四章：编程开发"></a>第十四章：编程开发</h2><p>·C&#x2F;C++</p><p>·Java</p><p>·Python</p><p>·JavaScript</p><p>·Go</p><h2 id="第十五章：容器与云服务"><a href="#第十五章：容器与云服务" class="headerlink" title="第十五章：容器与云服务"></a>第十五章：容器与云服务</h2><p>·AWS、Google Cloud Platform、Azure、阿里云、腾讯云、华为云</p><h2 id="第十六章：容器实战思考"><a href="#第十六章：容器实战思考" class="headerlink" title="第十六章：容器实战思考"></a>第十六章：容器实战思考</h2><p>·Docker为什么会成功：Docker首次创造了一种简单易行且覆盖应用全生命周期的工作流，用户通过简单的指令或Restful API来拉取、打包、运行和维护容器，从根本上降低了应用程序部署的难度，极大地提高了应用运行时环境的部署与维护的效率</p><h2 id="第十七章：核心实现技术"><a href="#第十七章：核心实现技术" class="headerlink" title="第十七章：核心实现技术"></a>第十七章：核心实现技术</h2><p>·基本架构</p><p>·命名空间</p><p>·控制组</p><p>·联合文件系统</p><p>·Linux网络虚拟化</p><h2 id="第十八章：配置私有仓库"><a href="#第十八章：配置私有仓库" class="headerlink" title="第十八章：配置私有仓库"></a>第十八章：配置私有仓库</h2><p>·安装Docker Registry</p><p>·配置TLS证书</p><p>·管理访问权限</p><p>·配置Registry</p><p>·批量管理镜像</p><p>·使用通知系统</p><h2 id="第十九章：安全防护与配置"><a href="#第十九章：安全防护与配置" class="headerlink" title="第十九章：安全防护与配置"></a>第十九章：安全防护与配置</h2><p>·命名空间隔离的安全</p><p>·控制组资源控制的安全</p><p>·内核能力机制</p><p>·Docker服务端的防护</p><p>·更多安全特性的使用</p><p>·使用第三方检测工具</p><h2 id="第二十章：高级网络功能"><a href="#第二十章：高级网络功能" class="headerlink" title="第二十章：高级网络功能"></a>第二十章：高级网络功能</h2><p>·启动与配置参数</p><p>·配置容器DNS和主机名</p><p>·容器访问控制</p><p>·映射容器端口到宿主主机的实现</p><p>·配置容器网桥</p><p>·自定义网桥</p><p>·使用OpenvSwitch网桥</p><p>·创建一个点到点连接</p><h2 id="第二十一章：libnetwork插件化网络功能"><a href="#第二十一章：libnetwork插件化网络功能" class="headerlink" title="第二十一章：libnetwork插件化网络功能"></a>第二十一章：libnetwork插件化网络功能</h2><p>·容器网络模型</p><p>·Docker网络命令</p><p>·构建跨主机容器网络</p><h2 id="第二十二章：Etcd-高可用的键值数据库"><a href="#第二十二章：Etcd-高可用的键值数据库" class="headerlink" title="第二十二章：Etcd-高可用的键值数据库"></a>第二十二章：Etcd-高可用的键值数据库</h2><p>·安装和使用Etcd</p><p>·使用客户端命令</p><p>·Etcd集群管理</p><h2 id="第二十三章：Docker三剑客之Machine"><a href="#第二十三章：Docker三剑客之Machine" class="headerlink" title="第二十三章：Docker三剑客之Machine"></a>第二十三章：Docker三剑客之Machine</h2><p>·安装和使用Machine</p><p>·Machine命令</p><h2 id="第二十四章：Docker三剑客之Compose"><a href="#第二十四章：Docker三剑客之Compose" class="headerlink" title="第二十四章：Docker三剑客之Compose"></a>第二十四章：Docker三剑客之Compose</h2><p>·安装和使用Compose</p><p>·Compose模板文件</p><p>·Compose命令和环境变量</p><h2 id="第二十五章：Docker三剑客之Swarm"><a href="#第二十五章：Docker三剑客之Swarm" class="headerlink" title="第二十五章：Docker三剑客之Swarm"></a>第二十五章：Docker三剑客之Swarm</h2><p>·使用Swarm</p><p>·使用服务命令</p><h2 id="第二十六章：Mesos-优秀的集群资源调度平台"><a href="#第二十六章：Mesos-优秀的集群资源调度平台" class="headerlink" title="第二十六章：Mesos-优秀的集群资源调度平台"></a>第二十六章：Mesos-优秀的集群资源调度平台</h2><p>·Mesos安装与使用</p><p>·原理与架构</p><p>·Mesos配置解析</p><p>·日志与监控</p><h2 id="第二十七章：Kubernetes-生产机容器集群平台"><a href="#第二十七章：Kubernetes-生产机容器集群平台" class="headerlink" title="第二十七章：Kubernetes-生产机容器集群平台"></a>第二十七章：Kubernetes-生产机容器集群平台</h2><p>·资源抽象对象</p><p>·控制器抽象对象</p><p>·其他抽象对象</p><h2 id="第二十八章：其他相关项目"><a href="#第二十八章：其他相关项目" class="headerlink" title="第二十八章：其他相关项目"></a>第二十八章：其他相关项目</h2><p>·持续集成</p><p>·容器管理</p><p>·编程开发</p><p>·网络支持</p><p>·日志处理</p><p>·服务代理</p><p>·标准与规划</p>]]></content>
    
    
    
    <tags>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码整洁之道</title>
    <link href="/2024/01/11/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <url>/2024/01/11/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章：整洁代码"><a href="#第一章：整洁代码" class="headerlink" title="第一章：整洁代码"></a>第一章：整洁代码</h2><p>·写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”，这种“代码感”是关键所在。</p><h2 id="第二章：有意义的命名"><a href="#第二章：有意义的命名" class="headerlink" title="第二章：有意义的命名"></a>第二章：有意义的命名</h2><p>·选好名称</p><p><img src="/../../../img/cleancode/image-20231229091103936.png"></p><p>上图中，theList、0下标、4、list1的意义都不明确，因此需要明确每个变量的命名</p><p><img src="/../../../img/cleancode/image-20231229091317906.png"></p><p>进一步可以将int[]另写为一个类Cell，抽象出isFlagged方法</p><p><img src="/../../../img/cleancode/image-20231229091327367.png"></p><p>·命名避免误导</p><p>·做有意义的区分：</p><p>1）以数字系列命名</p><p><img src="/../../../img/cleancode/image-20231229092358398.png"></p><p>上述代码貌似看起来没有问题，代码逻辑也较为简单，但是将命名修改为source和destination会更好，用a1和a2进行区分不够清晰，需要阅读代码后才能明白两个数组的作用</p><p>2）废话&#x2F;冗余</p><p>假设有一个Product类，如果还有ProductInfo类和ProductData类，那么这两者没有较大区别，无法从名称上进行快速区分，尽管在业务复杂的情况下可能确实需要这两个类，但使用者需要具体看类内部的成员变量与方法进行区分。</p><p>同样地，还有getActiveAccount()、getActiveAccounts()、getActiveAccoutnInfo()，开发者无法确定该调用哪个函数，因此命名应该有意义，而不是为了完成代码开发的任务而随意命名</p><p>·使用读的出来的名称</p><p><img src="/../../../img/cleancode/image-20231229093537771.png"></p><p>上面那种写法估计只有写代码的本人能看懂</p><p>·使用可搜索的名称：若变量或常量在代码中多处使用，应该赋予便于搜索的名称，便于搜索的名称一般会更长一些。如果使用单字母命名，如e，既无法表示命名意义，又不便于搜索</p><p>·避免使用编码：</p><p>1）将类型写入名称，如phoneNumber、phoneString</p><p>2）使用无意义的前缀，如m_dsc</p><p>·避免思维映射：不应当让读者在脑中把你的名称翻译为他们熟知的名称，因此命名时要确定好大家公认的术语</p><p>·类名：类名和对象名应当是名词或名词短语，类名不应当是动词</p><p>·方法名：应当是动词或动词短语，如postPayment、deletePage、save等</p><p>·别扮可爱：命名别太耍宝</p><p>·每个概念对应一个词：如fetch、retrieve和get都能表示一个意思，保持统一</p><p>·使用解决方案领域名称：只有程序员会读你的代码，因此如JobQueue等的命名是非常清晰可靠的</p><p>·添加有意义的语境：例如state命名，单看此名称无法推测它的含义，州？状态？因此需要添加有意义的语境，如addrState表示地址中的州，当然最好还是将地址抽象为一个类，这样state在地址类的语境里含义就明确了</p><p>·不要添加无意义的语境：如给大量的类添加一个前缀，代码自动补全时会出现一大堆列表</p><h2 id="第三章：函数"><a href="#第三章：函数" class="headerlink" title="第三章：函数"></a>第三章：函数</h2><p>·短小：函数的第一规则是要短小，例如if、else、while语句代码块中代码最好只有一行，一般为一个函数调用语句</p><p>·只做一件事：函数应该做一件事，做好这件事，只做这件事</p><p>·每个函数一个抽象层级：抽象出来的方法位于较高层，普通的代码逻辑操作位于较低层。函数中最好保证都处于同一个抽象层级，这样就可以让代码拥有自顶向下的阅读顺序，像一颗多叉树一样，将一段逻辑逐步分解到最底层的代码逻辑</p><p>·使用描述性名称：给函数取个好名称，用于描述函数做的事，别害怕长名称</p><p>·函数参数：最理想的参数数量是0，其次是1，再次是2，应尽量避免3。</p><p>·标识参数：函数中涉及标识参数不合理，例如函数参数中带有布尔值，这代表该函数会基于表示判断做不同的事，应该让标识位于上一层，并且基于该标识调用不同的函数</p><p>·二元函数：二元函数不算恶劣，但也可以尽可能将其转换为一元函数</p><p>·参数对象：如果函数需要两个、三个或三个以上的参数，可以考虑某些参数是否可以封装为类</p><p>·动词与关键字：函数名字应当较好地解释函数的意图，参数的顺序等。对于一元函数，函数和参数应当形成一种良好的动词&#x2F;名词形式，如write(name)</p><p>·无副作用：如函数名为checkPassword的如下代码，尽管函数名为checkPassword，但在方法内部还执行的Session的初始化操作。存在一定的风险，应当至少把函数名改为checkPasswordAndInitializeSession，虽然这还是违反了“只做一件事”的原则</p><p><img src="/../../../img/cleancode/image-20240108094819827.png"></p><p>·输出参数：参数多数时候用作函数的输入，然而在特定情况下参数会用作输出，如public void appendFooter(StringBuffer report)。针对输出参数，最好采用report.appendFooter()的方式进行调用。应当尽量避免输出参数的使用。</p><p>·分隔指令与询问：函数要么做什么事，要么回答什么事。如果函数同时修改某对象的状态、返回该对象的相关信息，会导致混乱。如public boolean set(String attribute, String value)，该函数的本意是设置某个指定属性，如果设置成功返回true，如果属性不存在返回false。那么具体使用时代码为if (set(“username”, “unclebob”))，会给读者造成混淆，这是在判断username属性是否之前就已经为unclebob，还是username属性是否成功设置为unclebob。为了解决这个问题，可以将函数命名为setAndCheckIfExists。更好的方案是将检查属性是否存在和设置属性抽象为两个方法，即attributeExists()和setAttribute()</p><p>·使用异常替代返回错误码：如下代码，三个操作中都返回错误码，错误码处理中使用了if else的三层嵌套，并且错误码的出现和错误码的处理不在同一个位置。</p><p><img src="/../../../img/cleancode/image-20240108100848251.png"></p><p>解决方案是使用异常，这样代码更加清晰，并且错误码和异常信息都在各自的函数中处理</p><p><img src="/../../../img/cleancode/image-20240108101132051.png"></p><p>·抽离try&#x2F;catch代码：try&#x2F;catch代码块会搞乱代码结构，并且把错误处理与正常流程混在一起，可以将try&#x2F;catch代码块的主题抽象为函数。具体处理如下。</p><p><img src="/../../../img/cleancode/image-20240108101553173.png"></p><p>·错误处理就是一件事：处理错误的函数不应该做其他事，这意味着try是该函数的第一个单词，并且在catch&#x2F;finally后也不应该其他逻辑处理</p><p>·Error.java依赖磁铁：返回错误码通常意味着有个类或者枚举，定义了所有错误码，这样的类&#x2F;枚举就是依赖磁铁dependency magnet，其他许多类都得导入和使用它，当Error枚举类修改时，其他类都得重新编译和部署。使用异常代替错误码，新异常可以从异常类中派生出来，无需重新编译或部署</p><p>·别重复：减少代码的重复，当代码在多处被反复使用时，需要将其抽象为方法，否则如果代码需要修改，就必须在多个地方进行。代码开发中许多原则和实践规则都是为了控制和消除重复而创建</p><p>·如何写出符合上述规范的函数：刚开始写的函数可能都冗长而复杂，后续可以打磨，并且保证测试通过</p><h2 id="第四章：注释"><a href="#第四章：注释" class="headerlink" title="第四章：注释"></a>第四章：注释</h2><p>好的注释可以帮助读者理解，坏的注释会使读者变得困惑。</p><p>代码表达是最重要的，好的代码可以让读者不需要注释即可清楚地明白这段逻辑的意义。针对难以表达清楚的地方或者需要特别注意的地方，可以使用注释。同时也要保证注释是可维护的，而不是一成不变。</p><p>·注释不能美化糟糕的代码：带有少量注释的整洁而有表达力的代码，要好于带有大量注释的零碎而复杂的代码。与其花时间解释糟糕的代码，不如花时间优化代码</p><p>·用代码来阐述：创建一个与注释所言同一事物的函数，而避免不重要的注释。参见两个写法的对比。</p><p><img src="/../../../img/cleancode/image-20240108110519868.png"></p><p>·好注释：有些注释是必须的，也是有利的。不过，唯一真正好的注释是想办法不去写的注释。</p><p>1）法律信息：版权及著作权声明有理由写在每个源文件的开头</p><p>2）提供信息的注释：解释入参、返回值、正则表达式格式等</p><p>3）对意图的解释：对于部分逻辑处理，可以写出自己当时如此编写代码的原因，参见以下的两个例子</p><p><img src="/../../../img/cleancode/image-20240108111124984.png"></p><p><img src="/../../../img/cleancode/image-20240108111135195.png"></p><p>4）阐释：注释把某些晦涩的参数或者返回值翻译为某种可读形式</p><p><img src="/../../../img/cleancode/image-20240108111322507.png"></p><p>5）警示：用于警示当前代码存在一定的风险</p><p><img src="/../../../img/cleancode/image-20240108111430390.png"></p><p><img src="/../../../img/cleancode/image-20240108111445569.png"></p><p>6）TODO注释：一种应该做，但目前还没做的工作。可能是提醒删除某个不必要的特性，或者提示他人注意某个问题等</p><p><img src="/../../../img/cleancode/image-20240108111723325.png"></p><p>7）放大：放大某种看起来不合理处理的重要性</p><p><img src="/../../../img/cleancode/image-20240108111818759.png"></p><p>8）公共api中的Javadoc</p><p>·坏注释：坏注释都是糟糕的代码的支撑或者接口，基本等于程序员自说自话</p><p>1）喃喃自语：如果只是因为你觉得应该或者过程需要而添加注释，那就是无谓之举。如果决定要写注释，就要将注释写清晰，保证他人也能看懂</p><p><img src="/../../../img/cleancode/image-20240108112235926.png"></p><p>2）多余的注释：如下的注释，读注释的时间也许比读代码花的时间还长。代码本身就很简单，注释既没有提供代码本身以外的信息，也没有证明代码的意义或者是意图</p><p><img src="/../../../img/cleancode/image-20240108112402531.png"></p><p>3）误导性注释：保证代码和注释的一致性，不然注释会误导他人</p><p>4）循规式注释：每个函数都要有Javadoc或每个变量都要有注释是不必要的</p><p>5）日志式注释：每次编辑代码时，在开头添加一条注释，记录每次的修改。这种也是不必要的，过于冗长。</p><p>6）废话注释</p><p><img src="/../../../img/cleancode/image-20240108113141612.png"></p><p><img src="/../../../img/cleancode/image-20240108113154560.png"></p><p><img src="/../../../img/cleancode/image-20240108113207084.png"></p><p>7）能用函数或变量表达清楚就别用注释，if中一大堆的代码可以用变量定义，使其逻辑更加清晰，而不是添加注释</p><p><img src="/../../../img/cleancode/image-20240108113439972.png"></p><p>8）位置标记</p><p><img src="/../../../img/cleancode/image-20240108113602395.png"></p><p>9）归属与署名：代码控制系统会记录谁做了修改</p><p><img src="/../../../img/cleancode/image-20240108143554805.png"></p><p>10）注释掉的代码：废弃的代码直接删除即可，代码控制系统会帮助记录此前的代码，不用担心删去的代码找不到了。直接将代码注释，其他人也不敢删，会认为代码被注释有其原因。</p><p><img src="/../../../img/cleancode/image-20240108143643607.png"></p><p>11）注释信息过多</p><p><img src="/../../../img/cleancode/image-20240108144002167.png"></p><h2 id="第五章：格式"><a href="#第五章：格式" class="headerlink" title="第五章：格式"></a>第五章：格式</h2><p>·概念间垂直方向上的区隔：每行展现一个表达式或子句，每组代码行展示一个完整的思路，思路之间用空白行分隔开</p><p><img src="/../../../img/cleancode/image-20240108145126088.png"></p><p><img src="/../../../img/cleancode/image-20240108145110780.png"></p><p>如果删除空白行，可读性大大降低</p><p><img src="/../../../img/cleancode/image-20240108145154267.png"></p><p>·垂直方向上的靠近： 紧密相关的代码应该互相靠近</p><p><img src="/../../../img/cleancode/image-20240108145446707.png"></p><p><img src="/../../../img/cleancode/image-20240108145458085.png"></p><p>孰优孰劣，一目了然</p><p>·垂直距离</p><p>1）变量声明：</p><p>本地变量在函数的顶部出现</p><p><img src="/../../../img/cleancode/image-20240108150410314.png"></p><p>实体变量在类的顶部声明。如果不在顶部声明，如下所示，这两个实体变量只会被无意间发现</p><p><img src="/../../../img/cleancode/image-20240108150455981.png"></p><p>2）相关函数：如果某个函数调用了另一个，应该将它们放在一起，并且调用者尽可能放在被调用者上方</p><p>3）概念相关：概念相关的代码放在一起</p><p><img src="/../../../img/cleancode/image-20240108150858283.png"></p><p>·水平方向上的区隔与靠近：巧用空格</p><p><img src="/../../../img/cleancode/image-20240108151620731.png"></p><p><img src="/../../../img/cleancode/image-20240108151632858.png"></p><p>·水平对齐：</p><p><img src="/../../../img/cleancode/image-20240108152051012.png"></p><p><img src="/../../../img/cleancode/image-20240108152102323.png"></p><p>尽力对齐一组声明中的变量名，或一组赋值语句中的右值。这种做法看起来较为整洁，但是也许会让读者更加关注变量名和右值，而忽视类型和赋值。</p><p>因此，也可以采用不对齐的声明和赋值</p><p><img src="/../../../img/cleancode/image-20240108152239732.png"></p><p>·缩进：大多数类声明不缩进，类中的方法相对该类缩进一个层级，方法的实现相对方法声明缩进一个层级，代码块的实现相对于其容器代码块缩进一个层级</p><p>以下是有无缩进的区别</p><p><img src="/../../../img/cleancode/image-20240108152641638.png"></p><p>·团队规则：遵循团队的代码格式</p><h2 id="第六章：对象和数据结构"><a href="#第六章：对象和数据结构" class="headerlink" title="第六章：对象和数据结构"></a>第六章：对象和数据结构</h2><p>·数据抽象：抽象的数据具有更高的扩展性</p><p><img src="/../../../img/cleancode/image-20240108153846529.png"></p><p><img src="/../../../img/cleancode/image-20240108153918776.png"></p><p>·数据、对象的反对称性</p><p><img src="/../../../img/cleancode/image-20240108154917314.png"></p><p>Geometry类操作三个形状类，形状类都是简单的数据结构，没有任何行为，行为都在Geometry类中</p><p><img src="/../../../img/cleancode/image-20240108155050062.png"></p><p>在多态式写法中，各自的形状类实现Shape接口，同时实现接口中定义的area()方法</p><p>以上两种方法各有优点，当形状类需要扩展时，第二种方法更好，无需修改此前的代码，只需要新定义形状类即可，而第一种方法除了要新定义形状类外，还需要修改Geometry类中的函数逻辑；当需要增加新函数时，第一种方法更好，只需要在Geometry类中新增函数，无需再其他类中改动，而第二种方法需要在接口和各形状类中都要新增，但感觉这两种方法工作量都差不多。总体来看，还是第二种方法更好。</p><p>·得墨忒耳律：类C的方法f只应该调用以下对象的方法</p><p>1）C</p><p>2）由f创建的对象</p><p>3）作为参数传递给f的对象</p><p>4）由C的实体变量持有的对象</p><p>·数据传送对象：最为精炼的数据结构，是一个只有公共变量、没有函数的类，这种数据结构被称为数据传送对象，或DTO（Data Transfer Objects）。DTO是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类的场景</p><p>对象暴露行为，隐藏数据，便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构暴露数据，没有明显的行为，便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</p><h2 id="第七章：错误处理"><a href="#第七章：错误处理" class="headerlink" title="第七章：错误处理"></a>第七章：错误处理</h2><p>·使用异常而非返回码</p><p>·使用不可控异常：可控异常会违反开放&#x2F;闭合原则，如果在方法中抛出可控异常，而catch语句在三个层级以上，就得在catch语句和抛出异常处之间的每个方法签名中声明该异常。对较低层级的修改，会影响较高层级的签名，修改好的模块必须重新构建、发布，即使它们自身所关注的东西并没有改动。</p><p>·给出异常发生的环境说明：应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型等。</p><p>·依调用者需要定义异常类：当我们在定义异常类时，应该考虑它们如何被捕获</p><p><img src="/../../../img/cleancode/image-20240109090454344.png"></p><p>如上所示的异常分类中，语句中包含了一大堆重复代码，可以对其进行简化</p><p><img src="/../../../img/cleancode/image-20240109090558065.png"></p><p><img src="/../../../img/cleancode/image-20240109090612783.png"></p><p>·有时可以不用异常：如下的例子</p><p><img src="/../../../img/cleancode/image-20240109091018089.png"></p><p>修改后，通过新建PerDiemMealExpenses类避免了异常处理</p><p><img src="/../../../img/cleancode/image-20240109091037526.png"></p><p><img src="/../../../img/cleancode/image-20240109091047481.png"></p><p>·别返回null值：如下的代码需要通过大量的代码去判断null值。（不过该检查还是得检查，不然空指针异常了）</p><p><img src="/../../../img/cleancode/image-20240109091659059.png"></p><p>尽量不要返回null值，可以通过抛异常或者特例对象的方式解决</p><p><img src="/../../../img/cleancode/image-20240109091731127.png"></p><p>针对以上代码，可以让getEmployees()返回null的时候返回空列表，这样就无需判断null值</p><p><img src="/../../../img/cleancode/image-20240109091808919.png"></p><p><img src="/../../../img/cleancode/image-20240109091821446.png"></p><p>·别传递null值：</p><p><img src="/../../../img/cleancode/image-20240109092547290.png"></p><p>如上的代码，如果有人传入null值就会得到空指针异常</p><p>如何修正？可以创建一个新的异常类型并抛出</p><p><img src="/../../../img/cleancode/image-20240109092629318.png"></p><p>在大多数编程语言中，没有良好的方法去应对由调用者意外传入的null值，恰当的做法就是禁止传递null值，避免以外</p><h2 id="第八章：边界"><a href="#第八章：边界" class="headerlink" title="第八章：边界"></a>第八章：边界</h2><p>·使用第三方代码</p><p>·浏览和学习边界</p><p>·学习性测试</p><p>·使用尚不存在的代码：意思是某个项目依赖与其他人的代码，但其他人还没有定义相应的接口，此时我们可以自己定义需要使用的接口 ，使用尚不存在的代码进行代码开发</p><p>·整洁的边界：包装第三方代码，或者使用Adapter模式将我们的接口转换为第三方提供的接口，来实现整洁的边界</p><h2 id="第九章：单元测试"><a href="#第九章：单元测试" class="headerlink" title="第九章：单元测试"></a>第九章：单元测试</h2><p>·TDD三大定律：TDD要求我们在编写生产代码前先编写单元测试，如下是TDD三大定律</p><p>1）在编写不能通过的单元测试前，不可编写生产代码</p><p>2）只可编写刚好无法通过的单元测试，不能编译也算不通过</p><p>3）只可编写刚好足以通过当前失败测试的生产代码</p><p>·保证测试整洁：脏测试等同于没测试。测试必须随生产代码的演进而修改，测试越脏，就越难修改。需要花更多的时间塞进新测试。修改生产代码后，旧测试可能会失败，测试代码中乱七八糟的东西会阻碍代码再次通过。随着版本迭代，团队维护测试代码的代价越来越高，最后只能扔掉整个测试代码组。没有了测试代码，开发者无法确保对系统某个部分的修改不会影响到系统的其他部分，故障率开始增加。所以，必须保证测试的整洁。乱七八糟的测试可能比没测试还差。</p><p>·整洁的测试</p><p>1）保证可读性，符合构造-操作-检验的模式</p><p>2）面向特定领域的测试语言：测试中没有直接使用对系统进行操作的API，而是重构打造一套包装了这些APi的函数和工具代码</p><p>3）双重标准：测试在测试环境中执行，与生产环境中的生产代码还是有所区别，在测试中也许不那么考虑内存或者CPU效率，不过仍然要保持整洁</p><p>·每个测试一个概念：每个测试函数只测试一个概念                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p><p>·FIRST规则</p><p>1）F：Fast，快速，测试应该能快速运行</p><p>2）I：Independent，测试之间相互独立，某个测试不应为下一个测试设定条件。当测试相互依赖时，一个没通过的测试会导致一连串的测试失败</p><p>3）R：Repeatable，测试应当可以在任何环境中重复通过</p><p>4）S：Self-Validating：测试应该由布尔值输出，无论是通过或失败，不应该通过查看日志来确认测试是否通过</p><p>5）T：Timely，测试应该及时编写。单元测试应该在使其通过的生产代码之前编写，如果在编写生产代码之后编写测试，可能会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试，可能不会去设计可测试的代码</p><h2 id="第十章：类"><a href="#第十章：类" class="headerlink" title="第十章：类"></a>第十章：类</h2><p>·类的组织：遵循标准的Java约定，类从一组变量列表开始。先是公共静态常量，然后是私有静态变量，以及私有实体变量。公共函数跟在变量列表之后，某个公共函数调用的私有工具函数紧跟在该公共函数后面，符合自顶向下原则</p><p>·类应该短小：系统应该由许多短小的类而不是少量巨大的类组成。</p><p>1）单一权责原则（SRP）：类或模块应有且只有一条加以修改的理由。类只应一个权责——只有一条修改的理由。鉴别权责（修改的理由）常常可以帮助我们在代码中认识并创建出更好的抽象</p><p>2）内聚：类应该只有少量的实体变量，类中的每个方法都应该操作一个或多个这种变量。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。一般来说，创建这种极大化内聚类既不可取也不可能，但是还是期望类的内聚性保持在较高的位置，类中的方法和变量相互依赖，互相结合成一个逻辑整体。</p><p>3）保持内聚性会得到许多短小的类：可以理解，一个冗长的类中，有些方法可能只操作到部分变量，证明内聚性较低。此时，将部分变量和方法抽象到新的类中，会提高内聚性，同时得到许多短小的类。</p><p>·为了修改而组织</p><p>如下的代码有多种修改理由，违背SRP原则，需要进行重构</p><p><img src="/../../../img/cleancode/image-20240109113028507.png"></p><p>重构后如下所示</p><p><img src="/../../../img/cleancode/image-20240109113154416.png"></p><p><img src="/../../../img/cleancode/image-20240109113205603.png"></p><p>重构后如果需要增加update语句，只需要在相应的小类中修改，而不会影响其他类。如果按重构前的写法，修改会在sql大类中执行，风险较大。重构后也符合开放-闭合原则（OCP），类应当对扩展开放，对修改封闭。在理想系统中，我们希望通过扩展系统而非修改现有代码来添加新特性</p><h2 id="第十一章：系统"><a href="#第十一章：系统" class="headerlink" title="第十一章：系统"></a>第十一章：系统</h2><p>·将系统的构造与使用分开：软件系统应将启始过程与启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系</p><p>1）分解main：将构造与使用分开的方法之一是将全部构造过程搬迁到main中</p><p>2）工厂：应用程序通过抽象工厂模式自行控制对象的创建，构造能力属于抽象工厂，应用程序与如何构建对象的细节是分离开的</p><p>3）依赖注入：依赖注入可以实现分离构造与使用。如Spring框架的IOC模块</p><p>·扩容</p><p>·Java代理</p><p>·纯Java AOP框架</p><p>·AspectJ的方面</p><p>·测试驱动系统架构</p><p>·优化决策</p><p>·明智使用添加了可论证价值的标准</p><p>·系统需要领域特定语言</p><h2 id="第十二章：迭进"><a href="#第十二章：迭进" class="headerlink" title="第十二章：迭进"></a>第十二章：迭进</h2><p>·通过迭进设计达到整洁目的</p><p>·简单设计规则</p><p>1）运行所有测试：确保系统完全可测试能帮助我们创建更好的设计。只要系统可测试，就会导向保持类短小且目的单一的设计方案。遵循SRP的类，测试起来较为简单。测试编写得越多，就越能持续走向编写较易测试的代码。</p><p>2）重构：提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称等，测试消除了对清理代码就会破坏代码的恐惧</p><p>3）不可重复：重复是拥有良好设计系统的大敌，它代表了额外的工作、额外的风险和额外且不必要的复杂度。可以通过模板方法模式来消除明显的重复，例如有两个逻辑，他们大部分逻辑相同，小部分逻辑不一致，此时可以创建抽象类，并定义相关方法，相同的逻辑只需定义一遍，不同的逻辑由各自的继承类去重写</p><p>4）表达力：软件项目的主要成本在于长期维护。所以，代码应当清晰地表达作者的意图。</p><p>5）尽可能少的类和方法：类和方法数量太多，有时是无意义的教条主义导致的。我们应该在保持函数和类短小的同时，保持整个系统短小精悍，类和方法的数量尽可能少。这条规则优先级最低，在保证以上规则的前提下保持尽可能少的类和方法</p><h2 id="第十三章：并发编程"><a href="#第十三章：并发编程" class="headerlink" title="第十三章：并发编程"></a>第十三章：并发编程</h2><p>·并发防御原则</p><p>1）单一权责原则（SRP）：单一权责原则认为，方法&#x2F;类&#x2F;组件应当只有一个修改的理由，并发设计本身足够复杂到成为修改的理由，所以应该从其他代码中分离出来</p><p>2）限制数据作用域：两个线程修改共享对象的同一字段时，可能相互干扰，导致未预期的行为。解决方案之一是使用synchronized关键字在代码中保护一块使用共享对象的临界区</p><p>3）使用数据副本：使用数据副本可以避免共享数据</p><p>4）线程应尽可能独立：线程应该成为自己世界里的唯一线程，不与其他线程共享数据</p><p>·了解执行模型</p><p>1）生产者-消费者模型</p><p>2）读者-作者模型</p><p>3）宴席哲学家</p><p>·警惕同步方法之间的依赖：避免使用一个共享对象的多个方法</p><p>·保持同步区域微小：锁是昂贵的，它们带来了延迟和额外开销。应该尽可能减小同步区域</p><p>·很难编写正确的关闭代码：尽早考虑关闭问题，尽早令其工作正常。平静关闭很难做到，并发编程中可能出现死锁，导致系统无法正常关闭</p><p>·测试线程代码：对于多线程情况，测试较为困难，测试通过也无法保证并发过程完全没有问题。应该编写有潜力暴露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行</p><p>1）将伪失败看作可能的线程问题：不要将系统错误归咎于偶发事件</p><p>2）先使非线程代码可工作：不要同时追踪非线程缺陷和线程缺陷，确保代码在线程之外可工作</p><p>3）编写可插拔的线程代码：编写可插拔的线程代码，可以在不同的配置环境下运行</p><p>4）编写可调整的线程代码：要获得良好的线程平衡，常常需要试错。一开始，在不同的配置环境下监测系统性能，要允许线程数量可调整</p><p>5）运行多于处理器数量的线程：任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。</p><p>6）在不同平台上运行：在不同环境中，多线程代码的行为也不一致，尽早并经常地在所有目标平台上运行线程代码</p><p>7）装置试错代码：增加对Object.wait()、Object.sleep()、Object.yield()、Object.priority()等方法的调用，改变代码执行顺序，从而增加检测到缺陷的可能性</p><p>8）硬编码：向代码中加入Object.wait()、Object.sleep()、Object.yield()、Object.priority()等方法的调用</p><p>9）自动化：可以使用Aspect-Oriented Frameword、CGLIB、ASM之类的工具通过编程来装置代码</p><h2 id="第十四章：逐步改进"><a href="#第十四章：逐步改进" class="headerlink" title="第十四章：逐步改进"></a>第十四章：逐步改进</h2><p>作者介绍了一个自己逐步改进、重构代码的例子</p><h2 id="第十五章：JUnit内幕"><a href="#第十五章：JUnit内幕" class="headerlink" title="第十五章：JUnit内幕"></a>第十五章：JUnit内幕</h2><p>作者以Junit的源码为例，讲解了重构的一些思路</p><h2 id="第十六章：重构SerialDate"><a href="#第十六章：重构SerialDate" class="headerlink" title="第十六章：重构SerialDate"></a>第十六章：重构SerialDate</h2><h2 id="第十七章：味道与启发"><a href="#第十七章：味道与启发" class="headerlink" title="第十七章：味道与启发"></a>第十七章：味道与启发</h2><p>·注释</p><p>1）不恰当的信息：注释只应该描述有关代码和设计的技术性信息，如作者、最后修改时间等会被源代码控制系统记录</p><p>2）废弃的注释：过时、无关、不正确的注释是废弃的注释，如果发现废弃注释，最好尽快更新或删除</p><p>3）冗余注释：注释应该谈及代码自身没提到的信息</p><p>4）糟糕的注释：如果要写注释，就要花时间保证写出最好的注释，别闲扯、画蛇添足，保持简洁</p><p>5）注释掉的代码：你注释掉的代码，其他人没人敢删。随着时间推移，注释掉的代码逐渐腐烂，调用不复存在的函数，使用已改名的变量。注释掉的代码应该删除，源代码控制系统会记录它，不用担心丢失</p><p>·环境</p><p>1）需要多步才能实现的构建：构建系统应该是单步的小操作</p><p>2）需要多步才能实现的测试：应当能够发出单个指令就可以运行全部单元测试</p><p>·函数</p><p>1）过多的参数：函数的参数应该尽可能少，没参数，一个，两个，三个，三个以上的参数非常值得质疑，应该坚决避免</p><p>2）输出参数：输出参数违反直觉</p><p>3）标识参数：布尔值参数表明函数做了不只一件事（true时do something，false时do something else），应该杜绝</p><p>4）死函数：永不被调用的方法应该丢弃</p><p>·一般性问题</p><p>1）一个源文件中存在多种语言</p><p>2）明显的行为未被实现：函数或类应该实现其他程序员有理由期待的行为</p><p>3）不正确的边界行为：注意边界条件，编写测试</p><p>4）忽视安全：忽视某些告警</p><p>5）重复：重复代码，意味着遗漏了抽象。重复代码可以用单一方法来替代；在不同模块重复出现的，可以用多态代替；采用类似算法但具体代码行不同的模块，可以使用模板方法模式或者策略模式来替代</p><p>6）在错误的抽象层级上的代码：创建抽象类来容纳较高层级概念，创建派生类来容纳较低层级概念。例如将某个函数放在很高的层级，但是有些派生类没有与该函数相关的概念，说明这个函数放在了过高的层级</p><p>7）基类依赖于派生类：通常来说，基类对派生类应该一无所知</p><p>8）信息过多：不要创建拥有大量方法或大量实体变量的类，不要为子类创建大量受保护变量和函数。。。</p><p>9）死代码：如果你找到死代码，就体面地埋葬它，将它从系统中删除</p><p>10）垂直分隔：变量和函数应该在靠近被使用的地方定义，本地变量应该在其首次被使用的位置上面声明，垂直距离要短。私有函数应该在其首次被使用的位置下面定义。</p><p>11）前后不一致：举个例子，如果在特定函数中用response变量持有HttpServletResponse对象，则在其他用到HttpServletResponse对象的函数中也用同样的变量名</p><p>12）混淆视听：没有用到的变量，从不调用的函数，没有信息量的注释，都应该清除</p><p>13）人为耦合：不互相依赖的东西不该耦合。人为耦合是指两个没有直接目的之间的模块的耦合</p><p>14）特性依恋：类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数</p><p>15）选择算子参数：类似于布尔值参数。使用多个函数，优于向单个函数传递某些代码来选择函数行为</p><p>16）晦涩的意图：代码要尽可能具有表达力，下面的写法就是一个反例</p><p><img src="/../../../img/cleancode/image-20240110153218687.png"></p><p>17）位置错误的权责：在哪里放代码？需要好好决策</p><p>18）不恰当的静态方法：如果的确需要静态函数，确保没机会打算让它有多态行为</p><p>19）使用解释性变量：如果不用key和value，直接调用put函数的话，1和2的含义都是未知的</p><p><img src="/../../../img/cleancode/image-20240110153819734.png"></p><p>20）函数名称应该表达其行为</p><p>21）理解算法：搞懂自己的代码是如何工作的，而不是通过测试就了事</p><p>22）把逻辑依赖改为物理依赖</p><p>23）用多态替代if else或switch case</p><p>24）遵循标准约定：每个团队都应遵循基于通用行业规范的一套编码标准</p><p>25）用命名常量替代魔术数，例如用SECONDS_PER_DAY替代数字86400</p><p>26）准确</p><p>27）结构甚于约定：命名约定很好，但却次于强制性的结构</p><p>28）封装条件：没有if或while语句的上下文，布尔逻辑难以理解，应该把解释了条件意图的函数抽离出来</p><p><img src="/../../../img/cleancode/image-20240110161013869.png"></p><p>29）避免否定性条件：否定性比肯定性难以理解，尽可能将条件表示为肯定性</p><p><img src="/../../../img/cleancode/image-20240110161110376.png"></p><p>30）函数只做一件事</p><p>31）掩蔽时序耦合：有必要使用时序耦合，不应该掩盖它</p><p>下面的代码没有强制这种时序耦合</p><p><img src="/../../../img/cleancode/image-20240110162652925.png"></p><p>修改后如下，通过创建顺序队列暴露了时序耦合，保证按顺序调用三个函数</p><p><img src="/../../../img/cleancode/image-20240110162730720.png"></p><p>32）封装边界条件：边界条件难以追踪，把处理边界条件的代码集中到一处，不要散落于代码中</p><p><img src="/../../../img/cleancode/image-20240110163104176.png"></p><p>33）函数应该只在一个抽象层级上</p><p>34）在较高层级放置可配置数据</p><p>35）避免传递浏览：如果A与B协作，B与C协作，不应该让A的去了解C的信息，而是通过让直接协作者提供所需的全部服务。例如，A调用B，让B去提供操作C的方法，供A调用</p><p>·Java</p><p>1）通过使用通配符避免过长的导入清单：如果使用了来自同一程序包的两个或多个类，用以下语句导入整个包</p><p>import package.*;</p><p>2）不要继承常量：用静态导入常量所在的类，而不是通过继承该类而去使用常量</p><p>3）常量和枚举：大胆用枚举，枚举比常量提供了更多表达力和灵活性的工具</p><p>·名称</p><p>1）采用描述性名称：花时间明智地取名</p><p>2）名称应与抽象层级相符：取反映类或函数抽象层级的名称</p><p>3）尽可能使用标准命名法：例如将对象转换为字符串的函数通常命名为toString；开发团队也有自己的命名标准系统</p><p>4）无歧义的名称：选用不会混淆函数或变量意义的名称，例如doRename函数里还有个renamePage，这两个函数之间难以区分</p><p>5）为较大作用范围选用较长名称：名称的作用范围越大，名称就该越长、越准确。在小范围中，如i、j这种命名也是合理的</p><p>6）避免编码：不应在名称中包括类型或作用范围信息，无意义</p><p>7）名称应该说明副作用：例如一个函数获取一个oos，如果oos不存在，则会创建。如果取名为getOos，则不能反映创建的过程，最好命名为createOrReturnOos</p><p>·测试</p><p>1）测试不足：一套测试应该测到所有可能失败的东西</p><p>2）使用覆盖率工具：使用覆盖率工具汇报测试中的缺口</p><p>3）别略过小测试：小测试易于编写，其文档上的价值高于编写成本</p><p>4）被忽略的测试就是对不确定事物的疑问</p><p>5）测试边界条件：边界条件不能遗漏</p><p>6）全面测试相近的缺陷：如果在某个函数中发现一个缺陷，最好全面测试这个函数，缺陷可能不止一个</p><p>7）测试应该快速</p>]]></content>
    
    
    
    <tags>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode常见算法题</title>
    <link href="/2023/12/20/Leetcode%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2023/12/20/Leetcode%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Hot100"><a href="#LeetCode-Hot100" class="headerlink" title="LeetCode Hot100"></a>LeetCode Hot100</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><img src="/img/leetcode/1677160961940-e4c8dc6f-b449-491f-a01f-0183fb1b43f7.png"></p><p>利用哈希表O(1)的查找时间复杂度，将原本的两次循环转换为一次循环，实现O(n)的时间复杂度。</p><p>map.containsKey()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public int[] twoSum(int[] nums, int target) &#123;<br>        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>        for(int i = 0; i &lt; nums.length; ++i) &#123;<br>            if(map.containsKey(target - nums[i])) &#123;<br>                return new int[]&#123;i, map.get(target - nums[i])&#125;;<br>            &#125; else &#123;<br>                map.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        return null;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p><img src="/img/leetcode/1677161346147-1b417918-7c0b-483c-8db5-0bf1f6ca65d2.png"></p><p>模拟，利用while循环一直遍历到两个链表的最后一位(不要循环到两个链表的交集处，这样处理起来不方便)，如果当前链表节点为空，则计数时算0，如果节点和大于9，那么要进1。循环结束之后还需要判断，因为可能还需要进位，判断over是否为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;<br>        int a = 0;<br>        int b = 0;<br>        int over = 0;<br>        ListNode dummy = new ListNode();<br>        ListNode cur = dummy;<br>        while(l1 != null || l2 != null) &#123;<br>            a = l1 == null ? 0 : l1.val;<br>            b = l2 == null ? 0 : l2.val;<br>            int sum = a + b + over;<br>            int now = sum % 10;<br>            over = sum / 10;<br>            cur.next = new ListNode(now);<br>            cur = cur.next;<br>            if(l1 != null) &#123;<br>                l1 = l1.next;<br>            &#125;<br>            if(l2 != null) &#123;<br>                l2 = l2.next;<br>            &#125;      <br>        &#125;<br>        if(over != 0) &#123;<br>            cur.next = new ListNode(over);<br>        &#125;<br>        return dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p><img src="/img/leetcode/1677199789118-09a06cdb-82b4-4f91-92b9-4fa189303ecd.png"></p><p>滑动窗口，用map去记录当前窗口内每个字符出现的频率，当遍历一个字符，导致该字符频率大于1时，说明该字符发生重复，此时用while循环让左指针向右滑动，直到该字符的频率等于1，此时可以计算当前窗口的长度，与res取大值即可。</p><p>滑动窗口的本质就是减少无效的遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public int lengthOfLongestSubstring(String s) &#123;<br>        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();<br>        char[] cs = s.toCharArray();<br>        int l = 0, r = 0;<br>        int res = 0;<br>        while(r &lt; s.length()) &#123;<br>            map.put(cs[r], map.getOrDefault(cs[r], 0) + 1);<br>            if(map.get(cs[r]) &gt; 1) &#123;<br>                while(map.get(cs[r]) &gt; 1) &#123;<br>                    map.put(cs[l], map.getOrDefault(cs[l], 0) - 1);<br>                    ++l;<br>                &#125;<br>            &#125;<br>            ++r;<br>            res = Math.max(res, r - l);<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><p><img src="/img/leetcode/1677202066561-8e606fe7-0f26-498f-8a92-fa2e46486b50.png"></p><p>定义两个数组的左指针，遍历比较大小，将两个数组按正序归并到一个大数组上，大数组中间元素或者中间两个元素的平均值即为返回值。此时时间复杂度为O(m+n)，还不满足题目的要求。（不需要创建一个大的数组，直接用两个左指针遍历，找到中位数那个&#x2F;两个位置的元素即可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;<br>        int[] rec = new int[nums1.length + nums2.length];<br>        int l1 = 0, l2 = 0;<br>        int ptr = 0;<br>        while(l1 &lt; nums1.length &amp;&amp; l2 &lt; nums2.length) &#123;<br>            if(nums1[l1] &lt;= nums2[l2]) &#123;<br>                rec[ptr++] = nums1[l1];<br>                ++l1;<br>            &#125; else &#123;<br>                rec[ptr++] = nums2[l2];<br>                ++l2;<br>            &#125;<br>        &#125;<br>        if(l1 == nums1.length) &#123;<br>            while(l2 &lt; nums2.length) &#123;<br>                rec[ptr++] = nums2[l2];<br>                ++l2;<br>            &#125;<br>        &#125; else &#123;<br>            while(l1 &lt; nums1.length) &#123;<br>                rec[ptr++] = nums1[l1];<br>                ++l1;<br>            &#125;<br>        &#125;<br>        if(rec.length % 2 == 0) &#123;<br>            return (double) (rec[rec.length / 2] + rec[rec.length / 2 - 1]) / 2;<br>        &#125; else &#123;<br>            return (double) rec[rec.length / 2];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分法：该题可以转化成寻找两个有序数组中的第k小的数(注意k是第k小，而不是下标)。通过比较两个数组里的第[k&#x2F;2 -1]个元素，两个元素中较小值及其之前的元素可以被排除在外。[k&#x2F;2 - 1]个元素前有k&#x2F;2 - 1个元素，因此两个元素的较小值大于k - 2个元素，较小值是k -1个元素。所以较小值和其前面的元素可以被排除在外，那么数组长度减少了，k的取值也可以相应减少，相当于是排除了几个最小值，那么k也相应减少。为什么比较[k&#x2F;2 - 1]个元素，通过前面的分析，可以看到这样的话，较小值是k - 1个元素，如果比较[k&#x2F;2]个元素，那么较小值就是k + 1个元素，超过了第k小的要求。为什么不取较大值进行排除？因为无法确定较大值超过了多少个元素，也许较大值就是第k小元素，只有较小值超过了多少元素是可以确定的。</p><p>有以下三种情况需要特殊处理：</p><p><img src="/img/leetcode/1677204095807-fe0a9a8f-199d-4b49-a96f-adc6f62bea6f.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;<br>        int n1 = nums1.length, n2 = nums2.length;<br>        int sum = n1 + n2;<br>        if(sum % 2 == 0) &#123;<br>            return (double) (getK(nums1, nums2, sum / 2) + getK(nums1, nums2, sum / 2 + 1)) / 2;<br>        &#125; else &#123;<br>            return (double) getK(nums1, nums2, sum / 2 + 1);<br>        &#125;<br>    &#125;<br><br>    private int getK(int[] nums1, int[] nums2, int k) &#123;<br>        <br>        int n1 = nums1.length, n2 = nums2.length;<br>        // 被剪切数组的第一个下标<br>        int l1 = 0, l2 = 0;<br><br>        while(true) &#123;<br>            <br>            if(l1 == n1) &#123;<br>                return nums2[l2 + k - 1];<br>            &#125;<br>            if(l2 == n2) &#123;<br>                return nums1[l1 + k - 1];<br>            &#125;<br>            if(k == 1) &#123;<br>                return Math.min(nums1[l1], nums2[l2]);<br>            &#125;<br><br>            int half = k / 2;<br>          // 不能越界<br>            int newl1 = Math.min(l1 + half - 1, n1 - 1);<br>            int newl2 = Math.min(l2 + half - 1, n2 - 1);<br>            if(nums1[newl1] &lt;= nums2[newl2]) &#123;<br>                k = k - newl1 + l1 - 1; <br>                l1 = newl1 + 1;<br>            &#125; else &#123;<br>                k = k - newl2 + l2 - 1;<br>                l2 = newl2 + 1;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p><img src="/img/leetcode/1677206017656-03f986df-ffc3-4889-931b-674eed6f28d3.png"></p><p>动态规划，将回文子串的判断基于子问题。</p><p>创建boolean[][] dp &#x3D; new boolean[n][n] 表示从i位置到j位置的字符串是否为回文串，大字符串的回文串判断只需要该dp数组通过O(1)的时间复杂度即可得到，而无需重新判断该大字符串内部的字符串是否为回文串。</p><p>需要两重循环，第一层循环遍历子串的长度，第二层循环遍历子串开始的下标。由此可以得到子串的开头下标和结束下标，如果这两个字符不一致，那么肯定不是回文串，将dp[][]设为false；如果这两个字符一致，分两种情况，如果该字符串只有二&#x2F;三个字符，那么肯定是回文串，否则判断dp[i + 1][j - 1]是否为回文串。如果dp[i][j]为true，则与最大长度进行比较，如果此时长度更大，则更新最大长度，并记录此时的回文串开头下标。最后利用开头下标和最大长度，调用substring方法即可。如果不记录begin，那么又得重新遍历dp数组，去得到最大长度及相应的字符串。</p><p>注意，需要初始化dp数组！即将dp[i][i]都设为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public String longestPalindrome(String s) &#123;<br>        int n = s.length();<br>        if(n &lt; 2) &#123;<br>            return s;<br>        &#125;<br>        int maxLen = 1;<br>        int begin = 0;<br>        boolean[][] dp = new boolean[n][n];<br>        //初始化dp,长度为1的字符串为回文串<br>        for(int i = 0; i &lt; n; ++i) &#123;<br>            dp[i][i] = true;<br>        &#125;<br>        char[] cs = s.toCharArray();<br>        // 遍历子串长度<br>        for(int i = 2; i &lt;= n; ++i) &#123;<br>            // 遍历子串开始下标<br>            for(int j = 0; j &lt; n; ++j) &#123;<br>                int end = j + i - 1;<br>                if(end &gt;= n) &#123;<br>                    break;<br>                &#125;<br>                if(cs[j] != cs[end]) &#123;<br>                    dp[j][end] = false;<br>                &#125; else &#123;<br>                    if(end - j &lt; 3) &#123;<br>                        dp[j][end] = true;<br>                    &#125; else &#123;<br>                        dp[j][end] = dp[j + 1][end - 1];<br>                    &#125;<br>                &#125;<br>                if(dp[j][end] &amp;&amp; end - j + 1 &gt; maxLen) &#123;<br>                    maxLen = end - j + 1;<br>                    begin = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return s.substring(begin, begin + maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-正则表达式匹配"><a href="#6-正则表达式匹配" class="headerlink" title="6. 正则表达式匹配"></a>6. 正则表达式匹配</h2><p><img src="/img/leetcode/1677207867921-58c37cde-d951-481b-897b-6b2b3fb534b4.png"></p><p>注意<em>匹配零个或多个前面那个元素，不是说该位置可以代表零个或者多个前面那个元素，而是说前面那个元素加上</em>可以代表零个或多个前面那个元素，即*可以让前面那个元素消失。</p><p>动态规划，dp[i][j]，表示s前i个字符与p中前j个字符能否匹配。</p><p>（1）此时分情况讨论，如果p[j]是小写字母，那么比较s[i]和p[j]是否相同，如果相同，则dp[i][j] &#x3D; dp[i-1][j-1]；如果不相同，则不匹配，为false。</p><p>（2）如果p[j]是<em>，那么比较s[i]和p[j-1]是否相同，如果不相同，那么</em>可以让p[j-1]消失，所以dp[i][j]&#x3D;dp[i][j-2]；如果相同，那么<em>可以让p[j-1]消失，也可以继续匹配s[i-1]，相当于</em>可以代表多个当前元素，两种情况下有一种成功就成功，所以dp[i][j] &#x3D; dp[i][j-2] || dp[i-1][j]。</p><p>（3）如果p[j]是.，那么和情况1相同，不过此时一定会匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public boolean isMatch(String s, String p) &#123;<br>        int m = s.length();<br>        int n = p.length();<br>        boolean[][] dp = new boolean[m + 1][n + 1];<br>        // base case, 两个都是空串时匹配成功<br>        dp[0][0] = true;<br>        // 注意到这里的i和j与字符串中的索引并不对应,而是索引+1<br>        for(int i = 0; i &lt;= m; ++i) &#123;<br>            // 从1开始就行,因为j = 0时,除了dp[0][0]其他均为false,而dp数组默认就是false,无需重复遍历<br>            for(int j = 1; j &lt;= n; ++j) &#123;<br>                if(p.charAt(j - 1) == &#x27;*&#x27;) &#123;<br>                    dp[i][j] = dp[i][j - 2];<br>                    if(match(s, p, i, j - 1)) &#123;<br>                        dp[i][j] = dp[i][j] || dp[i - 1][j];<br>                    &#125;<br>                &#125; else &#123;<br>                    if(match(s, p, i, j)) &#123;<br>                        dp[i][j] = dp[i - 1][j - 1];<br>                    &#125; else &#123;<br>                        dp[i][j] = false;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return dp[m][n];<br>    &#125;<br><br>    private boolean match(String s, String p, int a, int b) &#123;<br>        if(a == 0 || b == 0) &#123;<br>            return false;<br>        &#125;<br>        if(p.charAt(b - 1) == &#x27;.&#x27;) &#123;<br>            return true;<br>        &#125;<br>        return s.charAt(a - 1) == p.charAt(b - 1);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-盛最多水的容器"><a href="#7-盛最多水的容器" class="headerlink" title="7. 盛最多水的容器"></a>7. 盛最多水的容器</h2><p><img src="/img/leetcode/1677380938075-9d0957fb-3dd7-4b8a-8fe5-1410a051d0cf.png"></p><p>双指针，最开始分别指向数组最左端和最右端，此时可以计算出这种情况下水的容积。此时让高度较小的一侧向中间移动，可以证明如果高度较小的一侧不移动，让高度较高的一侧移动，在所有情况下水的容积都不会超过现在的容积，因此直接让高度较小的一侧向中间移动即可，相当于用O(1)的时间复杂度代替了O(n)的时间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public int maxArea(int[] height) &#123;<br>        int l = 0, r = height.length - 1;<br>        int res = 0;<br>        while(l &lt; r) &#123;<br>            int cur = Math.min(height[l], height[r]) * (r - l);<br>            res = Math.max(res, cur);<br>            if(height[l] &lt;= height[r]) &#123;<br>                ++l;<br>            &#125; else &#123;<br>                --r;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-三数之和"><a href="#8-三数之和" class="headerlink" title="8. 三数之和"></a>8. 三数之和</h2><p><img src="/img/leetcode/1678262147030-3cf9b86a-46ed-4481-90a4-d5f231a19fd6.png"></p><p>去重，排序+双指针</p><p>普通的三数之和采用三重循环即可，但是这个要求不能重复，因此需要去重。</p><p>如何去重，先对数组进行排序，然后根据前后元素是否一致来判断即可，即同一层遍历里不能遍历相同元素，遇到需要continue。</p><p>然而此时还是三重循环，采用排序+双指针，可以将三重循环内的两重循环简化为O(n)的时间复杂度，因为在一个有序数组里，第一个元素逐渐增大，那么第二个元素肯定在原来位置的左侧，第二个元素无需再次从最右侧开始向左遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        for(int i = 0; i &lt; nums.length; ++i) &#123;<br>            int r = nums.length - 1;<br>            if(i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;<br>                continue;<br>            &#125;<br>            for(int j = i + 1; j &lt; nums.length; ++j) &#123;<br>                if(j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;<br>                    continue;<br>                &#125;<br>                while(r &gt; j &amp;&amp; nums[i] + nums[j] + nums[r] &gt; 0) &#123;<br>                    --r;<br>                &#125;<br>                if(r == j) &#123;<br>                    break;<br>                &#125;<br>                if(nums[i] + nums[j] + nums[r] == 0) &#123;<br>                    res.add(Arrays.asList(nums[i], nums[j], nums[r]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-电话号码的字母组合"><a href="#9-电话号码的字母组合" class="headerlink" title="9. 电话号码的字母组合"></a>9. 电话号码的字母组合</h2><p><img src="/img/leetcode/1677387437251-512f2099-d990-43d0-9157-79bdd347fafe.png"></p><p>回溯，创建String数组用来表示数字和字母之间的映射关系</p><p>StringBuilder删除某个位置元素的方法：sb.deleteCharAt()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    List&lt;String&gt; res = new ArrayList&lt;&gt;();<br>    public List&lt;String&gt; letterCombinations(String digits) &#123;<br>        if(digits == null || digits.length() == 0) &#123;<br>            return res;<br>        &#125;<br>        String[] rec = new String[]&#123;&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;<br>        backTracking(digits, 0, new StringBuilder(), rec);<br>        return res;<br>    &#125;<br><br>    void backTracking(String digits, int start, StringBuilder sb, String[] rec) &#123;<br>        if(start == digits.length()) &#123;<br>            res.add(sb.toString());<br>            return;<br>        &#125;<br>        char c = digits.charAt(start);<br>        for(int i = 0; i &lt; rec[c - &#x27;2&#x27;].length(); ++i) &#123;<br>            sb.append(rec[c - &#x27;2&#x27;].charAt(i));<br>            backTracking(digits, start + 1, sb, rec);<br>            sb.deleteCharAt(sb.length() - 1);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-删除链表的倒数第N个结点"><a href="#10-删除链表的倒数第N个结点" class="headerlink" title="10. 删除链表的倒数第N个结点"></a>10. 删除链表的倒数第N个结点</h2><p><img src="/img/leetcode/1677387669419-8f777204-e512-4a2f-a0fb-8bc0bd6f7940.png"></p><p>快慢指针，让快指针领先慢指针相应的结点数量，当快指针为null时，慢指针到达要删除的结点的前一个位置，即可快速地实现删除操作。</p><p>添加dummy结点！这样删除头结点和其他结点都是统一的，不然不够统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">behind</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(n-- &gt;= <span class="hljs-number">0</span>) &#123;<br>            behind = behind.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(behind != <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.next;<br>            behind = behind.next;<br>        &#125;<br>        cur.next = cur.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-有效的括号"><a href="#11-有效的括号" class="headerlink" title="11. 有效的括号"></a>11. 有效的括号</h2><p><img src="/img/leetcode/1677388890172-2cc8889c-ec6b-46ec-aa26-588a0bc709a0.png"></p><p>栈，有几种情况需要判断。</p><ol><li>stack为空，当前字符为右括号，return false</li><li>字符与栈最上面的字符不匹配，return false</li><li>最后如果栈不为空，表示还有剩余的左括号，return false</li></ol><p>所以，如果当前字符是左括号，直接push；如果是右括号，先判断stack是否为空，再判断左右字符是否匹配。</p><p>遍历完全部字符后，最后判断stack是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : cs) &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                stack.push(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">if</span>(stack.pop() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#125;&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">if</span>(stack.pop() != <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span>(stack.pop() != <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-合并两个有序链表"><a href="#12-合并两个有序链表" class="headerlink" title="12. 合并两个有序链表"></a>12. 合并两个有序链表</h2><p><img src="/img/leetcode/1677389346331-2e7e1e2a-3cf9-446e-9b4c-f1674ad64997.png"></p><p>迭代，首先创建一个dummy节点，然后遍历list1和list2，while循环的条件是遍历到某个链表循环到null，而不是把两条链表所有的节点都遍历完。最后将还未遍历完的节点赋到当前节点的next即可，是有序的。</p><p>此时空间复杂度是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(list1.val &lt; list2.val) &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list1.val);<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list2.val);<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = list1 == <span class="hljs-literal">null</span> ? list2 : list1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时空间复杂度是O(1)，直接对链表里的节点进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(list1.val &lt; list2.val) &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = list1 == <span class="hljs-literal">null</span> ? list2 : list1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-括号生成"><a href="#13-括号生成" class="headerlink" title="13. 括号生成"></a>13. 括号生成</h2><p><img src="/img/leetcode/1677399336155-96b12446-8119-432e-a64a-b67c62e889f2.png"></p><p>回溯，根据前面有效括号的判断，在左括号数量足够的情况下，左括号可以append；在当前StringBuilder的左括号数量大于右括号数量时，右括号可以添加，如果左括号数量小于等于右括号，右括号不能再添加，会产生无效的括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br><br>    List&lt;String&gt; res = new ArrayList&lt;&gt;();<br><br>    public List&lt;String&gt; generateParenthesis(int n) &#123;<br>        backTracking(new StringBuilder(), 0, 0, n);<br>        return res;<br>    &#125;<br><br>    void backTracking(StringBuilder sb, int left, int right, int cnt) &#123;<br>        if(left == cnt &amp;&amp; right == cnt) &#123;<br>            res.add(sb.toString());<br>        &#125;<br>        if(left &lt; cnt) &#123;<br>            sb.append(&#x27;(&#x27;);<br>            backTracking(sb, left + 1, right, cnt);<br>            sb.deleteCharAt(sb.length() - 1);<br>        &#125;<br>        if(right &lt; left) &#123;<br>            sb.append(&#x27;)&#x27;);<br>            backTracking(sb, left, right + 1, cnt);<br>            sb.deleteCharAt(sb.length() - 1);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-合并K个升序链表"><a href="#14-合并K个升序链表" class="headerlink" title="14. 合并K个升序链表"></a>14. 合并K个升序链表</h2><p>与合并两个升序链表有相似之处，可以将它视为若干次的合并两个升序链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.length; ++i) &#123;<br>            res = mergeTwoLists(res, lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>分治合并，base case是合并两个原始链表，层层往上，第二层就是合并两个被合并过一次的链表，最终得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode[] list, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(l == r) &#123;<br>            <span class="hljs-keyword">return</span> list[l];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> mergeTwoLists(merge(list, l, m), merge(list, m + <span class="hljs-number">1</span>, r));<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-下一个排列"><a href="#15-下一个排列" class="headerlink" title="15. 下一个排列"></a>15. 下一个排列</h2><p><img src="/img/leetcode/1677406831127-f9b3f0bd-7a41-4402-8430-91831e421b41.png"></p><p>找到最靠右的较小值（越靠右的值改变说明才是越接近当前的数值）</p><p>同时找到该值右侧第一个大于该值的值，不能从左侧去找，不然的话数值变小了</p><p>因此从后向前遍历，从后向前遍历一个升序数组，当遍历的数值不再满足升序数组时停止遍历，此时该值就是最靠右的较小值；同时从后向前遍历该升序数组，第一个大于的就是可以替换的数字。</p><p>最后该升序数组通过双指针的方式进行翻转，这样该区间从前到后就是升序。</p><p>如果发现p1为-1，说明该数字是最大排列，将整个区间进行反转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public void nextPermutation(int[] nums) &#123;<br>        int p1 = nums.length - 2;<br>        while(p1 &gt;= 0) &#123;<br>            if(nums[p1] &lt; nums[p1 + 1]) &#123;<br>                break;<br>            &#125;<br>            --p1;<br>        &#125;<br>        if(p1 == -1) &#123;<br>            reverse(nums, 0, nums.length - 1);<br>            return;<br>        &#125;<br>        int p2 = nums.length - 1;<br>        while(p2 &gt;= 0) &#123;<br>            if(nums[p2] &gt; nums[p1]) &#123;<br>                break;<br>            &#125;<br>            --p2;<br>        &#125;<br>        int temp = nums[p1];<br>        nums[p1] = nums[p2];<br>        nums[p2] = temp;<br>        reverse(nums, p1 + 1, nums.length - 1);<br>    &#125;<br><br>    void reverse(int[] nums, int l, int r) &#123;<br>        while(l &lt; r) &#123;<br>            int temp = nums[l];<br>            nums[l] = nums[r];<br>            nums[r] = temp;<br>            ++l;<br>            --r;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-最长有效括号"><a href="#16-最长有效括号" class="headerlink" title="16. 最长有效括号"></a>16. 最长有效括号</h2><p><img src="/img/leetcode/1677496018903-719a64b1-f566-4112-a934-1d471a46a478.png"></p><p>动态规划，dp[i]表示以i为结尾的最长有效括号长度。如果当前位置是’(‘，那么以该下标为结尾的长度肯定为0。</p><p>如果当前位置是’)’，那么判断前一个位置，如果是’(‘，说明dp[i] &#x3D; dp[i - 2] + 2；如果是’)’，那么继续判断[s - dp[i - 1] - 1]，如果该位置是’(‘，说明该字符串形如((……))，可以形成有效括号，因此dp[i] &#x3D; dp[i - 1] + dp[i - dp[i - 1] - 2] + 2。</p><p>注意越界判断！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()];<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span>(cs[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(cs[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> - dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; cs[i - <span class="hljs-number">1</span> - dp[i - <span class="hljs-number">1</span>]] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        dp[i] = dp[i - <span class="hljs-number">1</span>] + (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            max = Math.max(max, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-搜索旋转排序数组"><a href="#17-搜索旋转排序数组" class="headerlink" title="17. 搜索旋转排序数组"></a>17. 搜索旋转排序数组</h2><p><img src="/img/leetcode/1677498305894-213c6602-03a6-4524-bc2c-90bce299d7ba.png"></p><p>整个数组是无序的，但是在中间划分成两个区域，一个区域是有序的，另一个是无序的，在有序的区间内判断，如果target在此区间，则将区间缩小到该区间，否则将搜寻区间搜小到另一个区间。这种重复查询，直到查到target。判断有序区间的原因是，只有在有序区间内才能判断target是否在该区间，然后确定下一步的搜索范围。通过nums[0]和nums[m]大小就可以判断是左区间有序还是右区间有序。</p><p>注意小于等于号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[m] == target) &#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[m] &gt;= nums[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[m]) &#123;<br>                    r = m - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = m + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(nums[m] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;<br>                    l = m + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = m - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-在排序数组中查找元素的第一个和最后一个位置"><a href="#18-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="18. 在排序数组中查找元素的第一个和最后一个位置"></a>18. 在排序数组中查找元素的第一个和最后一个位置</h2><p><img src="/img/leetcode/1678264379322-400727f6-9493-486b-a4bf-93588319cb49.png"></p><p>相当于查找寻找第一个大于等于target的下标，第一个大于target的下标-1。</p><p>需要校验得到的leftIdx和rightIdx，如果不符合条件，返回-1，-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightIdx</span> <span class="hljs-operator">=</span> binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;leftIdx, rightIdx&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">boolean</span> flag)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>, ans = nums.length;<br>        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nums[m] &gt; target || (flag &amp;&amp; nums[m] &gt;= target)) &#123;<br>                r = m - <span class="hljs-number">1</span>;<br>                ans = m;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-组合总和"><a href="#19-组合总和" class="headerlink" title="19. 组合总和"></a>19. 组合总和</h2><p><img src="/img/leetcode/1677502193961-908069c7-7329-4a62-9fbb-1974e6b0dc85.png"></p><p>回溯，因为是同一个数可重复选取，因此回溯中start的参数就是i，不需要是i + 1，此时进行下一次backTracking时还可以选取i位置的数。同时可以进行剪枝操作，但必须对数组进行排序，当target - c[i] &lt; 0时，说明后面的也都不可能了，直接break。</p><p>此处需要用start记录遍历的起始下标，start之前的都不能再遍历，否则会重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(candidates);<br>        backTracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] c, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, LinkedList list)</span> &#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; c.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(target - c[i] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            list.add(c[i]);<br>            backTracking(c, target - c[i], i, list);<br>            list.remove(list.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-接雨水"><a href="#20-接雨水" class="headerlink" title="20. 接雨水"></a>20. 接雨水</h2><p><img src="/img/leetcode/1677554426541-d334a17b-403d-423e-86e1-87f816bef518.png"></p><p>对于下标i，下雨后水能到达的最大高度是下标i两边的最大高度的最小值，i处能接的雨水量等于最大高度-height[i]。</p><p>可以用动态规划的方法用O(n)的时间复杂度分别计算左侧（包括自己）和右侧（包括自己）的最大高度，然后遍历height数组得到水量。包括自己的话，这样Math.min最小都为0，不会出现负数，水量还减少的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int n = height.length;<br>        int[] left = new int[n];<br>        int[] right = new int[n];<br>        left[0] = height[0];<br>        right[n - 1] = height[n - 1];<br>        for(int i = 1; i &lt; n; ++i) &#123;<br>            left[i] = Math.max(height[i], left[i - 1]);<br>        &#125;<br>        for(int i = n - 2; i &gt;= 0; --i) &#123;<br>            right[i] = Math.max(height[i], right[i + 1]);<br>        &#125;<br>        int res = 0;<br>        for(int i = 1; i &lt; n - 1; ++i) &#123;<br>            res += Math.min(left[i], right[i]) - height[i];<br>        &#125;<br>        return res;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>单调栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public int trap(int[] height) &#123;<br>        int ans = 0;<br>        Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();<br>        int n = height.length;<br>        for (int i = 0; i &lt; n; ++i) &#123;<br>            while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;<br>                int top = stack.pop();<br>                if (stack.isEmpty()) &#123;<br>                    break;<br>                &#125;<br>                int left = stack.peek();<br>                int currWidth = i - left - 1;<br>                int currHeight = Math.min(height[left], height[i]) - height[top];<br>                ans += currWidth * currHeight;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-全排列"><a href="#21-全排列" class="headerlink" title="21. 全排列"></a>21. 全排列</h2><p><img src="/img/leetcode/1677588727648-c8efa9df-7805-47eb-b51a-f13af5679d0b.png"></p><p>全排列，链表中元素可以一致，只要顺序不同就是不同的排列。因此回溯时不能规定从哪个位置开始遍历，任何位置都有可能取到。用rec的boolean数组来记录该位置的元素是否已使用，使用的时候记得回溯！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();<br><br>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;<br>        int n = nums.length;<br>        boolean[] rec = new boolean[n];<br>        backTracking(rec, nums, new LinkedList&lt;&gt;());<br>        return res;<br>    &#125;<br><br>    void backTracking(boolean[] rec, int[] nums, List list) &#123;<br>        if(list.size() == nums.length) &#123;<br>            res.add(new ArrayList&lt;&gt;(list));<br>            return;<br>        &#125;<br>        for(int i = 0; i &lt; nums.length; ++i) &#123;<br>            if(rec[i]) &#123;<br>                continue;<br>            &#125;<br>            rec[i] = true;<br>            list.add(nums[i]);<br>            backTracking(rec, nums, list);<br>            list.remove(list.size() - 1);<br>            rec[i] = false;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-旋转图像"><a href="#22-旋转图像" class="headerlink" title="22. 旋转图像"></a>22. 旋转图像</h2><p><img src="/img/leetcode/1677589947729-061818f4-5152-48ff-a8b6-94643048408a.png"></p><ol><li>某个元素如何被旋转</li></ol><p>重点是要分析出某个位置的元素，分别转三次，所在的索引下标。</p><p>通过第一个元素与0行、0列的偏差分析，当旋转90°时，相当于行的差距变成了下一个位置列的差距，同理列的差距变成了下一个位置行的差距。经过两次旋转，行的差距和列的差距不变，不过基准变了，最开始的位置是在0行、0列的基础上+差距，而现在是在最长行、最长列的基础上-差距。</p><ol><li>要旋转哪些元素</li></ol><p>然后依次遍历到row&#x2F;2和(col + 1) &#x2F; 2，这样除了最中间的元素没有旋转，其余位置都已经被旋转。</p><p><img src="/img/leetcode/1677591598002-5e17b19b-f0ac-4bf1-8892-65e3f0da1b0e.png"></p><p><img src="/img/leetcode/1677591607117-b40d6e01-ab26-4924-be7b-2dd1a81be704.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public void rotate(int[][] matrix) &#123;<br><br>        int n = matrix.length;<br>        for(int i = 0; i &lt; n / 2; ++i) &#123;<br>            for(int j = 0; j &lt; (n + 1) / 2; ++j) &#123;<br>              // 四个元素的位置<br>                // int n1 = matrix[i][j];<br>                // int n2 = matrix[j][n - 1 - i];<br>                // int n3 = matrix[n - 1 - i][n - 1 - j];<br>                // int n4 = matrix[n - 1 - j][n - 1 - n + 1 + i];<br>                int temp = matrix[n - 1 - j][n - 1 - n + 1 + i];<br>                matrix[n - 1 - j][n - 1 - n + 1 + i] = matrix[n - 1 - i][n - 1 - j];<br>                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];<br>                matrix[j][n - 1 - i] = matrix[i][j];<br>                matrix[i][j] = temp;<br>            &#125;<br>        &#125;      <br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-字母异位词分组"><a href="#23-字母异位词分组" class="headerlink" title="23. 字母异位词分组"></a>23. 字母异位词分组</h2><p><img src="/img/leetcode/1677722924187-2d4d98d7-c88e-4273-aba4-1de11e04a1e7.png"></p><p>不同的字母异位词有其相同之处，因此把相同之处作为HashMap中的key即可。</p><p>可以先将字符串转换为字符数组，然后字符数组排序后重新创建字符串作为key即可。</p><p>也可以记录字符以及出现的次数，拼接StringBuilder，作为key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Solution &#123;<br>    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();<br>        for(String str : strs) &#123;<br>            char[] cs = str.toCharArray();<br>            Arrays.sort(cs);<br>            String key = new String(cs);<br>            List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;<br>        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-最大子数组和"><a href="#24-最大子数组和" class="headerlink" title="24. 最大子数组和"></a>24. 最大子数组和</h2><p><img src="/img/leetcode/1677724833788-f9ae5fe7-cbaf-4365-8b1a-80865f3294b2.png"></p><p>动态规划的思想，每次遍历的时候判断该元素是单独的，还是与前面可以合并。</p><p>此时动态规划只依赖于前一个元素，因此只需要O(1)的空间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            pre = Math.max(pre + num, num);<br>            res = Math.max(res, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-跳跃游戏"><a href="#25-跳跃游戏" class="headerlink" title="25. 跳跃游戏"></a>25. 跳跃游戏</h2><p><img src="/img/leetcode/1677725622839-389a0a6d-6c6b-4e06-bf45-443820970b3f.png"></p><p>贪心，实时记录当前可以跳跃到的最远下标。遍历元素，如果该元素在最远下标之内，更新最远下标；如果该元素在最远下标之外，无法到达，无需更新最远下表。如果遍历中最远下标&gt;&#x3D; n -1，说明可以到达，return ture。遍历结束后，return false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i &lt;= max) &#123;<br>                max = Math.max(max, i + nums[i]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(max &gt;= n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-合并区间"><a href="#26-合并区间" class="headerlink" title="26. 合并区间"></a>26. 合并区间</h2><p><img src="/img/leetcode/1677727155226-ecad4686-9865-4661-9db5-2e3f725a2e88.png"></p><p>排序，必须要排序，不然无法保证两个区间的一端是有序的，如果两个区间的两端都是无序，那么原来的覆盖区域的两端都可能要改变。</p><p>按区间的左端点进行排序，此时是否重叠可以通过当前区间左端点和重叠区间中最后一个区间的右端点大小来进行比较，无需再和重叠区间中其他区间比较，因为我们按照左端点进行排序，不可能和重叠区间中的其他区间重叠了。当发现有重叠时，更新重叠区间最后一个区间的右端点即可，左端点无需更新，因为我们按照左端点进行排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; gaps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        gaps.add(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; ++i) &#123;<br>            <span class="hljs-type">int</span>[] gap = intervals[i];<br>            <span class="hljs-type">int</span>[] last = gaps.get(gaps.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(gap[<span class="hljs-number">0</span>] &lt;= last[<span class="hljs-number">1</span>]) &#123;<br>                last[<span class="hljs-number">1</span>] = Math.max(last[<span class="hljs-number">1</span>], gap[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                gaps.add(gap);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// int[][] res = new int[gaps.size()][2];</span><br>        <span class="hljs-comment">// for(int i = 0; i &lt; gaps.size(); ++i) &#123;</span><br>        <span class="hljs-comment">//     res[i] = gaps.get(i);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return res;</span><br>        <span class="hljs-keyword">return</span> gaps.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[gaps.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-不同路径"><a href="#27-不同路径" class="headerlink" title="27. 不同路径"></a>27. 不同路径</h2><p><img src="/img/leetcode/1677727535227-402717b6-d584-4e84-8466-41aad527f8b1.png"></p><p>动态规划，每一个位置的路径可以由上一行和上一列的路径数相加。第一行和第一列的路径数为1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-最小路径和"><a href="#28-最小路径和" class="headerlink" title="28. 最小路径和"></a>28. 最小路径和</h2><p><img src="/img/leetcode/1677738412847-23db3fe1-0f2b-4df7-9df9-c572375109c6.png"></p><p>动态规划，dp记录走到当前位置的最小和，每个位置的最小和&#x3D;前一排&#x2F;前一列的最小和+当前位置的数。第一排和第一列的最小和直接累加即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-爬楼梯"><a href="#29-爬楼梯" class="headerlink" title="29. 爬楼梯"></a>29. 爬楼梯</h2><p><img src="/img/leetcode/1677741023450-6406d760-75a1-491b-8e11-4c6f724d6418.png"></p><p>动态规划，dp[i] &#x3D; dp[i - 1] + dp[i - 2]。由于涉及到i - 2，因此需要初始化。</p><p>这里我们new int[n + 1]，0下标表示0阶，1下标表示1阶，因为dp[2]需要加上dp[0]，因此这里dp[0]是1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="30-编辑距离"><a href="#30-编辑距离" class="headerlink" title="30. 编辑距离"></a>30. 编辑距离</h2><p><img src="/img/leetcode/1677844826798-ea8d236f-df2e-4328-a701-c1328a6dc599.png"></p><p>对两个单词进行插入，删除，替换本质上对应三种操作，对一个单词插入，对另一个单词插入，对一个单词替换。因为对一个单词插入，和对一个单词删除在最少操作数上是一致的。</p><p>动态规划，dp[i][j]表示将前i个元素换成j个元素需要的操作数。注意这里的i和j对应的是下标+1。</p><p>dp[i][j]可以从dp[i - 1][j]，dp[i][j - 1]，dp[i - 1][j - 1]中推算出，比如dp[i - 1][j] + 1就是当前操作下的最小操作数，即在i - 1后面插入一个元素即可。dp[i - 1][j - 1] + 1就是当前操作下的最小操作数，即替换任意一个字符即可，当然如果i - 1和j - 1下标的字符一致，无需替换，dp[i - 1][j - 1]就是dp[i][j]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word2.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = <span class="hljs-number">1</span> + Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-number">1</span> + Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-颜色分类"><a href="#31-颜色分类" class="headerlink" title="31. 颜色分类"></a>31. 颜色分类</h2><p><img src="/img/leetcode/1677847168500-b321acba-945b-4ea7-be7f-bbec6098b667.png"></p><p>单指针，遍历两次，第一次将0交换到头部，第二次将1交换到头部。</p><p>双指针，用指针p0交换0，指针p1交换1，如果遍历到1，这将该数与nums[p1]交换位置，并且p1++。交换p1时不需要担心后述的问题，因为p1始终大于等于p0。</p><p>如果遍历到0，则将该数与nums[p0]交换位置，并且将该位置再与nums[p1]交换，此时nums[p0]中可能存在的1就会被交换到p1，而不是被替换到外部。此时p0++，p1++。</p><p>注意只有当p0小于p1时才需要进行额外的交换操作，因为此时p0处是1，不进行额外的交换，1会被交换到后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, p1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[p1];<br>                nums[p1] = temp;<br>                ++p1;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = temp;<br>                <span class="hljs-keyword">if</span>(p0 &lt; p1) &#123;<br>                    temp = nums[i];<br>                    nums[i] = nums[p1];<br>                    nums[p1] = temp;<br>                &#125;<br>                ++p0;<br>                ++p1;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-最小覆盖子串"><a href="#32-最小覆盖子串" class="headerlink" title="32. 最小覆盖子串"></a>32. 最小覆盖子串</h2><p><img src="/img/leetcode/1677850463418-f944ab83-a0da-4eb5-af10-51ef78ea3a88.png"></p><p>这种不能无脑遍历的，只能通过O(n)的时间复杂度。</p><p>滑动窗口，右指针先往右，直到覆盖了，然后左指针往右，期间记录最小长度，以及起始下标。</p><p>如何判断覆盖，创建两个map。遍历t的map的key，如果在s的map中该key对应的val小于t中的key，return false。遍历结束，return true。</p><p>注意到里面的while循环中l &lt;&#x3D; r，此时长度为1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    Map&lt;Character, Integer&gt; ori = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Map&lt;Character, Integer&gt; cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ns</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nt</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nt; ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> t.charAt(i);<br>            ori.put(c, ori.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; ns) &#123;<br>            ++r;<br>            <span class="hljs-keyword">if</span>(r &lt; ns &amp;&amp; ori.containsKey(s.charAt(r))) &#123;<br>                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(check() &amp;&amp; l &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    begin = l;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(ori.containsKey(s.charAt(l))) &#123;<br>                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> begin == -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.substring(begin, begin + len);<br>    &#125;<br><br><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : ori.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span>(cnt.getOrDefault(entry.getKey(), <span class="hljs-number">0</span>) &lt; entry.getValue()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-子集"><a href="#33-子集" class="headerlink" title="33. 子集"></a>33. 子集</h2><p><img src="/img/leetcode/1677852580795-119d5b9e-7b04-4e99-a264-4a16e0721687.png"></p><p>回溯，要求元素不能相同，即用过的不能再用，此时我们通过设置一个start即可实现，每次遍历都从start位置开始，因此不会取到之前使用过的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        backTracking(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(), nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(LinkedList path, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; ++i) &#123;<br>            path.add(nums[i]);<br>            backTracking(path, nums, i + <span class="hljs-number">1</span>);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="34-单词搜索"><a href="#34-单词搜索" class="headerlink" title="34. 单词搜索"></a>34. 单词搜索</h2><p><img src="/img/leetcode/1677852821744-0298de90-ae23-4453-942f-c67946c71ad6.png"></p><p>回溯，回溯的时候要注意不能走重复的格子，因此需要用rec数组来记录格子是否被走过。</p><p>注意在主方法中循环那里也需要回溯，设置rec数组，同时要检查下标的合理性，防止越界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length, n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] rec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(flag) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                rec[i][j] = <span class="hljs-literal">true</span>;<br>                check(board, i, j, word, <span class="hljs-number">0</span>, rec);<br>                rec[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, String word, <span class="hljs-type">int</span> idx, <span class="hljs-type">boolean</span>[][] rec)</span> &#123;<br>        <span class="hljs-keyword">if</span>(board[row][col] != word.charAt(idx)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(idx == word.length() - <span class="hljs-number">1</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[]dir : dirs) &#123;<br>            <span class="hljs-keyword">if</span>(row + dir[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; row + dir[<span class="hljs-number">0</span>] &lt; board.length &amp;&amp; col + dir[<span class="hljs-number">1</span>] &lt; board[<span class="hljs-number">0</span>].length &amp;&amp; col + dir[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; !rec[row + dir[<span class="hljs-number">0</span>]][col + dir[<span class="hljs-number">1</span>]]) &#123;<br>                rec[row + dir[<span class="hljs-number">0</span>]][col + dir[<span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span>;<br>                check(board, row + dir[<span class="hljs-number">0</span>], col + dir[<span class="hljs-number">1</span>], word, idx + <span class="hljs-number">1</span>, rec);<br>                rec[row + dir[<span class="hljs-number">0</span>]][col + dir[<span class="hljs-number">1</span>]] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-柱状图中最大的矩形"><a href="#35-柱状图中最大的矩形" class="headerlink" title="35. 柱状图中最大的矩形"></a>35. 柱状图中最大的矩形</h2><p><img src="/img/leetcode/1677982878531-df7ce3cc-8122-4d19-a49e-ebdfe72a271d.png"></p><p>遍历每根柱子，并找到当前柱子左右两侧第一个比它矮的柱子，这两个柱子之间的柱子高度都大于等于当前柱子，因此可以计算出以当前柱子为高的矩形面积。</p><p>判断的时候是大于等于，此时相同高度的柱子的right[]是不正确的，但是没关系，相同高度的最后一根柱子的right值是正确的，不影响最后的结果！</p><p>注意Arrays.fill(right, n)和stack判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(right, n);<br><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> stack.pop();<br>                right[idx] = i;<br>            &#125;<br>            left[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res = Math.max(res, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="36-最大矩形"><a href="#36-最大矩形" class="headerlink" title="36. 最大矩形"></a>36. 最大矩形</h2><p><img src="/img/leetcode/1691310795618-c11005a9-953b-4bc6-b740-a32fd9c235cc.png"></p><p>和上一题类似，需要先记录每个位置往左连续1的长度</p><p>遍历每一列，得到每一列情况下的最大矩形，然后得到整个图形中的最大矩形</p><p>遍历每一列时，和上一题类似的解法，不过相当于转了个角度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(String[] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i].charAt(j) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    left[i][j] = j == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : left[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;      <br>      <br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>            <span class="hljs-type">int</span>[] down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>            Arrays.fill(down, m);<br>            Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    down[stack.pop()] = i;<br>                &#125;<br>                up[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                stack.push(i);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                max = Math.max(max, (down[i] - up[i] - <span class="hljs-number">1</span>) * left[i][j]);<br>            &#125;<br>             res = Math.max(max, res);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="37-二叉树的中序遍历"><a href="#37-二叉树的中序遍历" class="headerlink" title="37. 二叉树的中序遍历"></a>37. 二叉树的中序遍历</h2><p><img src="/img/leetcode/1691316622750-67966c0d-6106-4424-a89a-4bdd881c5c50.png"></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        list.add(root.val);<br>        dfs(root.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            res.add(root.val);<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="38-不同的二叉搜索树"><a href="#38-不同的二叉搜索树" class="headerlink" title="38. 不同的二叉搜索树"></a>38. 不同的二叉搜索树</h2><p><img src="/img/leetcode/1691317386057-2cea0095-3c0e-4e57-bf51-aa2b21be248f.png"></p><p>动态规划</p><p>dp[n]表示n个节点的二叉搜索树数量</p><p>dp[n]可以由不同的场景累加得到，分别是以1~n为根的数量，而以i为根的数量为dp[i - 1] * dp [n - i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="39-验证二叉搜索树"><a href="#39-验证二叉搜索树" class="headerlink" title="39. 验证二叉搜索树"></a>39. 验证二叉搜索树</h2><p><img src="/img/leetcode/1693986025964-623a42b0-de80-431d-b56f-560de666105a.png"></p><p>用pre记录前一个数，二叉搜索树遍历到的应该是递增，以此作为判断条件</p><p>pre设置为Long.MIN_VAULE，因为root的值可能为Integer.MIN_VALUE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        <span class="hljs-keyword">if</span>(root.val &gt; pre) &#123;<br>            pre = root.val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        <span class="hljs-keyword">return</span> l &amp;&amp; r;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-对称二叉树"><a href="#40-对称二叉树" class="headerlink" title="40. 对称二叉树"></a>40. 对称二叉树</h2><p><img src="/img/leetcode/1693986193484-85082a6b-c6bf-4636-9197-18fc6d23f7af.png"></p><p>dfs即可，入参是对称的两个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(root.left, root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node1, TreeNode node2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span> &amp;&amp; node2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node1.val != node2.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(node1.left, node2.right) &amp;&amp; dfs(node1.right, node2.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="41-二叉树的层序遍历"><a href="#41-二叉树的层序遍历" class="headerlink" title="41. 二叉树的层序遍历"></a>41. 二叉树的层序遍历</h2><p><img src="/img/leetcode/1693987578946-60e2ded0-d574-4ae4-8f8b-df52f9b0dea0.png"></p><p>用队列存，遍历前先获取当前层的size</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(cur.val);<br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                &#125;<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-二叉树的最大深度"><a href="#42-二叉树的最大深度" class="headerlink" title="42. 二叉树的最大深度"></a>42. 二叉树的最大深度</h2><p><img src="/img/leetcode/1693989235206-fa9d410a-488d-4ec8-ba38-722bcb026790.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> depth)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        depth++;<br>        max = Math.max(max, depth);<br>        dfs(root.left, depth);<br>        dfs(root.right, depth);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="43-从前序与中序遍历序列构造二叉树"><a href="#43-从前序与中序遍历序列构造二叉树" class="headerlink" title="43. 从前序与中序遍历序列构造二叉树"></a>43. 从前序与中序遍历序列构造二叉树</h2><p><img src="/img/leetcode/1693989286419-eab6b5cd-c65b-4b5a-b74e-1fec83568b8e.png"></p><p>前序遍历的第一个位置就是当前子树的根节点，从中序遍历数组中找到该节点索引下标，即可得知该根节点下左右子树的数量，再进一步将前序遍历中的数组分为左右两个子数组，依次可以获取到左右子树的根节点。</p><p>注意递归中最开始的判断，start &gt; end时return null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buildNode(preorder, inorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">buildNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> start2, <span class="hljs-type">int</span> end2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(end &lt; start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[start]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> map.get(preorder[start]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lLen</span> <span class="hljs-operator">=</span> idx - start2;<br>        cur.left = buildNode(preorder, inorder, start + <span class="hljs-number">1</span>, start + lLen, start2, idx - <span class="hljs-number">1</span>);<br>        cur.right = buildNode(preorder, inorder, start + lLen + <span class="hljs-number">1</span>, end, idx + <span class="hljs-number">1</span>, end2);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="44-二叉树展开为链表"><a href="#44-二叉树展开为链表" class="headerlink" title="44. 二叉树展开为链表"></a>44. 二叉树展开为链表</h2><p><img src="/img/leetcode/1693991670116-b0d62310-b0fc-480c-9533-6978d7db67f8.png"></p><p>先用list存前序遍历的TreeNode，空间复杂度O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; list.size(); i++) &#123;<br>            root.right = list.get(i);<br>            root.left = <span class="hljs-literal">null</span>;<br>            root = root.right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        list.add(root);<br>        dfs(root.left);<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-买卖股票的最佳时机"><a href="#45-买卖股票的最佳时机" class="headerlink" title="45. 买卖股票的最佳时机**"></a>45. 买卖股票的最佳时机**</h2><h2 id="46-二叉树中的最大路径和"><a href="#46-二叉树中的最大路径和" class="headerlink" title="46. 二叉树中的最大路径和**"></a>46. 二叉树中的最大路径和**</h2><h2 id="47-最长连续序列"><a href="#47-最长连续序列" class="headerlink" title="47. 最长连续序列"></a>47. 最长连续序列</h2><p><img src="/img/leetcode/1677990839832-8d389db4-8737-4ba0-be5e-ff1d276da043.png"></p><p>当遍历到某个元素x时，如果暴力，那么就得遍历数组查看有无x+1，时间复杂度很高。</p><p>因此将数字加入到set即可，这样O(1)的时间复杂度即可实现查找。</p><p>同时如果set中有x-1，那么x也无需再查找了，因为肯定比x-1的情况小。因此只有若干个数字需要进入查找，实现了O(n)的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : set) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> num + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(set.contains(next)) &#123;<br>                ++next;<br>                ++curLen;<br>            &#125;<br>            res = Math.max(res, curLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-只出现一次的数字"><a href="#48-只出现一次的数字" class="headerlink" title="48. 只出现一次的数字**"></a>48. 只出现一次的数字**</h2><h2 id="49-单词拆分"><a href="#49-单词拆分" class="headerlink" title="49. 单词拆分**"></a>49. 单词拆分**</h2><h2 id="50-环形链表"><a href="#50-环形链表" class="headerlink" title="50. 环形链表"></a>50. 环形链表</h2><p><img src="/img/leetcode/1677990027354-8b4a5620-6b24-4117-9c1a-43ba4c949562.png"></p><p>用set来判断有无重复的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(!set.add(head)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快慢指针，如果有环，快指针一定会追上慢指针</p><p>要注意空指针问题！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : head.next;<br>        <span class="hljs-keyword">while</span>(fast != slow) &#123;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-环形链表II"><a href="#51-环形链表II" class="headerlink" title="51. 环形链表II"></a>51. 环形链表II</h2><p><img src="/img/leetcode/1677991845146-e7fadfec-cc4b-4959-8eec-7295b0b2ab69.png"></p><p>快慢指针，当链表有null时说明无环，return null。</p><p>设入口之前节点数为a，环内节点数为b。</p><p>第一次相遇时，f &#x3D; 2s，f &#x3D; s + nb。推得s &#x3D;nb，f &#x3D; 2nb。</p><p>因此s再往前a就是head，此时让fast赋值为head。fast往前a也是head。因此他们相遇的时候就是入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        fast = head;<br>        <span class="hljs-keyword">while</span>(fast != slow) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="52-LRU缓存"><a href="#52-LRU缓存" class="headerlink" title="52. LRU缓存"></a>52. LRU缓存</h2><p><img src="/img/leetcode/1678064546392-e0b8bbb0-e699-476b-ae4f-261bdf720465.png"></p><p>哈希表+双向链表。哈希表用于从key找到dNode，否则需要遍历，时间复杂度提高。</p><p>该类中成员变量有map，size，capacity，head，tail。head和tail用于方便增删操作。</p><p>新建removeNode方法，addToHead方法，这两个方法组合就可以将LRU中的缓存从某个位置移动到头部。</p><p>新建removeTail方法，用于LRU驱逐最后一个节点，同时该节点要返回被驱逐的节点，需要在哈希表中删除。</p><p>需要注意往链表中添加元素时，需要及时更新map和size。当驱逐的时候，要从map中删除该节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">dNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        dNode prev;<br>        dNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">dNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">dNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, dNode&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> dNode head;<br>    <span class="hljs-keyword">private</span> dNode tail; <br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dNode</span>();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key)) &#123;<br>            <span class="hljs-type">dNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.get(key);<br>            removeAndAdd(cur);<br>            <span class="hljs-keyword">return</span> cur.val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key)) &#123;<br>            <span class="hljs-type">dNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.get(key);<br>            cur.val = value;<br>            removeAndAdd(cur);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">dNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dNode</span>(key, value);<br>            <span class="hljs-keyword">if</span>(size &lt; capacity) &#123;             <br>                addToHead(newNode);<br>                map.put(key, newNode);<br>                ++size;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">dNode</span> <span class="hljs-variable">drop</span> <span class="hljs-operator">=</span> removeTail();<br>                map.remove(drop.key);<br>                addToHead(newNode);<br>                map.put(key, newNode);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(dNode node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(dNode node)</span> &#123;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>        node.prev = head;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAndAdd</span><span class="hljs-params">(dNode node)</span> &#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> dNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">dNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> tail.prev;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-排序链表"><a href="#53-排序链表" class="headerlink" title="53. 排序链表"></a>53. 排序链表</h2><p><img src="/img/leetcode/1679390021523-428b3e8f-3b21-49b6-88e2-763d22d17b26.png"></p><p>归并排序，tail表示取不到的节点，类似于左闭右开。</p><p>当head为null时直接return head；当head.next &#x3D;&#x3D; tail，表示链表只有一个节点，此时返回该一个节点的链表，注意这里要把head.next设为null，因为区间是左闭右开。</p><p>通过快慢指针找到当前链表的中间点，然后分别对前后两个链表进行sortList，最后进行merge。</p><p>merge就是常规的升序合并两个链表。</p><p>此时空间复杂度是O（n），栈的空间。如果想要常量级空间复杂度，可以不用递归，for循环遍历，依次排序1-&gt;2-&gt;4-&gt;8直到排序的长度大于该链表的长度即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sortList(head, <span class="hljs-literal">null</span>);<br>    &#125;<br><br><br>    ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head, ListNode tail)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head.next == tail) &#123;<br>            head.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast != tail) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>            <span class="hljs-keyword">if</span>(fast != tail) &#123;<br>                fast = fast.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merge(sortList(head, slow), sortList(slow, tail));<br>    &#125;<br><br><br>    ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-乘积最大子数组"><a href="#54-乘积最大子数组" class="headerlink" title="54. 乘积最大子数组"></a>54. 乘积最大子数组</h2><p><img src="/img/leetcode/1678017632155-1fce2c7d-0ea9-4b8b-a0c7-1271b6195d3e.png"></p><p>这里需要设置两个dp数组，因为nums中可能有负数，所以情况比较多。</p><p>遍历从1开始！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>], max = nums[<span class="hljs-number">0</span>], res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cMin</span> <span class="hljs-operator">=</span> min;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cMax</span> <span class="hljs-operator">=</span> max;<br>            max = Math.max(cMax * nums[i], Math.max(nums[i], cMin * nums[i]));<br>            min = Math.min(cMin * nums[i], Math.min(nums[i], cMax * nums[i]));<br>            res = Math.max(res, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-最小栈"><a href="#55-最小栈" class="headerlink" title="55. 最小栈**"></a>55. 最小栈**</h2><h2 id="56-相交链表"><a href="#56-相交链表" class="headerlink" title="56. 相交链表"></a>56. 相交链表</h2><p><img src="/img/leetcode/1677993144890-ad4a044a-3a1a-454c-aeb9-462f27ed773b.png"></p><p>1）用HashSet，第一个相同的就是交点，时间复杂度O(m+n)，空间复杂度O(m)</p><p>2）先计算两个链表的长度，然后让其中长的链表，先走长度差。</p><p>然后一起遍历，如果有相同的就是交点；如果没有相同的，return null。</p><p>这太复杂了，需要遍历好几遍。</p><p>3）当A节点不为空，指向下一个；为空，指向B头结点。B节点也是同理。</p><p>假设A相交前长度a，B相交前长度b，相交部分c。</p><p>如果a&#x3D;b，那么第一次遍历时就相同。</p><p>如果a≠b，那么当他们都走a+b+c时，肯定同时走到交点处或者null</p><p>注意这里是cur &#x3D;&#x3D; null，遍历到尾节点的next空节点位置，才换到另一个链表头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curA</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curB</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-keyword">while</span>(curA != curB) &#123;<br>            curA = curA == <span class="hljs-literal">null</span> ? headB : curA.next;<br>            curB = curB == <span class="hljs-literal">null</span> ? headA : curB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="57-多数元素"><a href="#57-多数元素" class="headerlink" title="57. 多数元素**"></a>57. 多数元素**</h2><h2 id="58-打家劫舍"><a href="#58-打家劫舍" class="headerlink" title="58. 打家劫舍"></a>58. 打家劫舍</h2><p><img src="/img/leetcode/1677994256979-fc80c144-a0a5-43ac-a8d1-855dcf9a6fb0.png"></p><p>动态规划，dp[i]表示前i个房子能偷的最大数量。</p><p>此时状态转移方程为，dp[i] &#x3D; Math.max(dp[i -1], dp[i - 2] + nums[i])。此时无需判断i -1处有无被偷，没有被偷的话，dp[i - 1] &#x3D; dp[i - 2]，还是正确的，不需要额外判断。</p><p>因为涉及到i - 2，所以需要初始化dp[0]和dp[1]，dp[1]需要初始化为Math.max(nums[0], nums[1])。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="59-岛屿数量"><a href="#59-岛屿数量" class="headerlink" title="59. 岛屿数量"></a>59. 岛屿数量</h2><p><img src="/img/leetcode/1679389318711-766a1a42-9884-49e3-9f25-99e56bc831fc.png"></p><p>dfs遍历，每次dfs都会扫描到同样的位置，所以每次dfs都会扫描到相同的一整块。双重循环dfs每个位置，此时遍历没有被访问过的元素，因此不会重复计算。当当前元素是1，代表是岛屿，++res。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][m];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(!visited[i][j]) &#123;<br>                    <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        ++res;<br>                    &#125;<br>                    dfs(i, j, visited, grid);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] dir : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newX</span> <span class="hljs-operator">=</span> x + dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newY</span> <span class="hljs-operator">=</span> y + dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(newX &gt;= <span class="hljs-number">0</span> &amp;&amp; newX &lt; visited.length &amp;&amp; newY &gt;= <span class="hljs-number">0</span> &amp;&amp; newY &lt; visited[<span class="hljs-number">0</span>].length &amp;&amp; !visited[newX][newY] &amp;&amp; grid[x][y] == grid[newX][newY]) &#123;<br>                dfs(newX, newY, visited, grid);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="60-反转链表"><a href="#60-反转链表" class="headerlink" title="60. 反转链表"></a>60. 反转链表</h2><p><img src="/img/leetcode/1677998661375-938c5a8b-62ed-4fdb-95c2-d84e28fab13d.png"></p><p>设置一个pre节点，一个cur节点。同时用next节点保存cur的原始下一个节点，不然会被丢失。</p><p>pre从null开始，cur从head开始，反转后原始的头结点的下一节点应该为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="61-课程表"><a href="#61-课程表" class="headerlink" title="61. 课程表"></a>61. 课程表</h2><p><img src="/img/leetcode/1678101065741-7139a8d2-76b1-44c8-8e77-f4d04cba30a4.png"></p><p>拓扑排序，建图，创建visited数组和onPath数组，遍历节点调用traverse方法，traverse方法内部判断是否有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] onPath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> hasCycle;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[numCourses];<br>        onPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[numCourses];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(hasCycle) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            traverse(graph, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> !hasCycle;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(List&lt;Integer&gt;[] graph, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span>(onPath[p]) &#123;<br>            hasCycle = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(visited[p] || hasCycle) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        visited[p] = <span class="hljs-literal">true</span>;<br>        onPath[p] =  <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : graph[p]) &#123;        <br>            traverse(graph, i);<br>        &#125;<br>        onPath[p] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt;[] buildGraph(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] rels) &#123;<br>        List&lt;Integer&gt;[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] rel : rels) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> rel[<span class="hljs-number">1</span>], to = rel[<span class="hljs-number">0</span>];<br>            res[from].add(to);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="62-实现Trie（前缀树）"><a href="#62-实现Trie（前缀树）" class="headerlink" title="62. 实现Trie（前缀树）**"></a>62. 实现Trie（前缀树）**</h2><h2 id="63-数组中的第K个最大元素"><a href="#63-数组中的第K个最大元素" class="headerlink" title="63. 数组中的第K个最大元素"></a>63. 数组中的第K个最大元素</h2><p><img src="/img/leetcode/1678064861596-08d6796a-499a-4fa7-8bee-65f4a57365d4.png"></p><p>最小堆，时间复杂度O(nlogk)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a - b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            q.offer(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">peek</span> <span class="hljs-operator">=</span> q.peek();<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; peek) &#123;<br>                q.poll();<br>                q.offer(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于快排的减治方法</p><p>通过快排我们可以得到一个idx，该idx之前所有数小于该idx的元素，该idx之后所有数大于该idx的元素，即idx就是第[idx]大的数。我们与len - k比较，如果idx更大，说明需要前半区再次快排；否则需要在后半区再次快排。如果len - k &#x3D;&#x3D; idx，则直接返回nums[idx]。可以发现此时只需要对一个半区进行快排，这就是减治操作，不需要对两个半区都进行快排。</p><p>需要注意这里要设置一个Random对象，这样保证快排每次挑选的基准下标是随机的，防止数组是有序状态下导致时间复杂度提高。</p><p>快排的思路是，将randomIdx和left的元素先互换，然后将left + 1和right中的元素进行交换，while(true)循环，从左往右搜索找到大于base的第一个下标，从右往左搜索找到小于base的第一个下标。如果r &lt; l，说明已经排序结束，直接break，否则就交换这两个位置。</p><p>并且注意！交换位置后要相应++l，–r。</p><p>最后left+1，right已经排序了，此时left和r进行交换，将原来的基准放到正确的位置，并且return r。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums.length - k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> quicksort(nums, left, right);<br>            <span class="hljs-keyword">if</span>(target == idx) &#123;<br>                <span class="hljs-keyword">return</span> nums[idx];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; idx) &#123;<br>                left = idx + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = idx - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomIdx</span> <span class="hljs-operator">=</span> left + random.nextInt(right - left + <span class="hljs-number">1</span>);<br>        swap(nums, left, randomIdx);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>, r = right;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; nums[l] &lt; base) &#123;<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; nums[r] &gt; base) &#123;<br>                --r;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(r &lt; l) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            swap(nums, l, r);<br>            ++l;<br>            --r;<br>        &#125;<br>        swap(nums, left, r);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="64-最大正方形"><a href="#64-最大正方形" class="headerlink" title="64. 最大正方形**"></a>64. 最大正方形**</h2><h2 id="65-翻转二叉树"><a href="#65-翻转二叉树" class="headerlink" title="65. 翻转二叉树**"></a>65. 翻转二叉树**</h2><h2 id="66-回文链表"><a href="#66-回文链表" class="headerlink" title="66. 回文链表"></a>66. 回文链表</h2><p><img src="/img/leetcode/1678012347777-5ef18dfb-9221-4aa8-bf30-8885162d17a4.png"></p><p>先将链表里的数值添加到List<Integer>中，然后用双指针判断是否回文。空间复杂度O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">if</span>(list.get(l) != list.get(r)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="67-二叉树的最近公共祖先"><a href="#67-二叉树的最近公共祖先" class="headerlink" title="67. 二叉树的最近公共祖先**"></a>67. 二叉树的最近公共祖先**</h2><h2 id="68-除自身以外数组的乘积"><a href="#68-除自身以外数组的乘积" class="headerlink" title="68. 除自身以外数组的乘积**"></a>68. 除自身以外数组的乘积**</h2><h2 id="69-滑动窗口最大值"><a href="#69-滑动窗口最大值" class="headerlink" title="69. 滑动窗口最大值**"></a>69. 滑动窗口最大值**</h2><h2 id="70-搜索二维矩阵II"><a href="#70-搜索二维矩阵II" class="headerlink" title="70. 搜索二维矩阵II**"></a>70. 搜索二维矩阵II**</h2><h2 id="71-会议室II"><a href="#71-会议室II" class="headerlink" title="71. 会议室II**"></a>71. 会议室II**</h2><h2 id="72-完全平方数"><a href="#72-完全平方数" class="headerlink" title="72. 完全平方数**"></a>72. 完全平方数**</h2><h2 id="73-移动零"><a href="#73-移动零" class="headerlink" title="73. 移动零**"></a>73. 移动零**</h2><h2 id="74-寻找重复数"><a href="#74-寻找重复数" class="headerlink" title="74. 寻找重复数"></a>74. 寻找重复数</h2><p><img src="/img/leetcode/1679387194567-1cc0194a-66f4-4d2e-8be0-73c393e40cf6.png"></p><p>判断重复数每个二进制位是否为1，此时判断nums[i]中第i位为1的个数为x，1-n中第i为1的个数为y。如果x大于y，表示重复数该位置为1。确定重复数每个二进制位是否为1即可得到重复数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; bit &lt; <span class="hljs-number">32</span>; ++bit) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span>((nums[i] &amp; (<span class="hljs-number">1</span> &lt;&lt; bit)) != <span class="hljs-number">0</span>) &#123;<br>                    ++x;<br>                &#125; <br>                <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">1</span> &amp;&amp; (i &amp; (<span class="hljs-number">1</span> &lt;&lt; bit)) != <span class="hljs-number">0</span>) &#123;<br>                    ++y;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(x &gt; y) &#123;<br>                res |= <span class="hljs-number">1</span> &lt;&lt; bit;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="75-二叉树的序列化与反序列化"><a href="#75-二叉树的序列化与反序列化" class="headerlink" title="75. 二叉树的序列化与反序列化**"></a>75. 二叉树的序列化与反序列化**</h2><h2 id="76-最长递增子序列"><a href="#76-最长递增子序列" class="headerlink" title="76. 最长递增子序列"></a>76. 最长递增子序列</h2><p><img src="/img/leetcode/1678012597553-53252d97-7463-4ce0-b870-f441517dc597.png"></p><p>动态规划，dp[i]表示以i位置作为下标的最长长度。因此两重循环，里面的循环比较nums[i]和nums[j]，如果nums[i]大于nums[j]，那么dp[j] + 1就是这种情况下的长度。那么每次遍历都更新dp[i]和res即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    res = Math.max(res, dp[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="77-删除无效的括号"><a href="#77-删除无效的括号" class="headerlink" title="77. 删除无效的括号"></a>77. 删除无效的括号</h2><h2 id="78-最佳买卖股票时机含冷冻期"><a href="#78-最佳买卖股票时机含冷冻期" class="headerlink" title="78. 最佳买卖股票时机含冷冻期**"></a>78. 最佳买卖股票时机含冷冻期**</h2><h2 id="79-戳气球"><a href="#79-戳气球" class="headerlink" title="79. 戳气球**"></a>79. 戳气球**</h2><h2 id="80-零钱兑换"><a href="#80-零钱兑换" class="headerlink" title="80. 零钱兑换**"></a>80. 零钱兑换**</h2><h2 id="81-打家劫舍III"><a href="#81-打家劫舍III" class="headerlink" title="81. 打家劫舍III"></a>81. 打家劫舍III</h2><p><img src="/img/leetcode/1678019721512-9c858fb8-9b92-4651-aee9-ad2d9b5f61d3.png"></p><p>与数组的打家劫舍相比，稍微复杂了一点，同样还是分类讨论，如果选这个节点，那么就无法选该节点的左右节点，因此val &#x3D; node.val + l[1] + r[1]。如果不选这个节点，那么左右节点可选可不选，因此val &#x3D; Math.max(l[0], l[1]) + Math.max(r[0], r[1])。0位置表示选这个节点的最大值，1位置表示不选该节点的最大值。</p><p>需要将int[]返回给父节点用以计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] rec = dfs(root);<br>        <span class="hljs-keyword">return</span> Math.max(rec[<span class="hljs-number">0</span>], rec[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span>[] l = dfs(root.left);<br>        <span class="hljs-type">int</span>[] r = dfs(root.right);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">beforeMax</span> <span class="hljs-operator">=</span> Math.max(l[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>]) + Math.max(r[<span class="hljs-number">0</span>], r[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>] + root.val;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;curMax, beforeMax&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-比特位计数"><a href="#82-比特位计数" class="headerlink" title="82. 比特位计数**"></a>82. 比特位计数**</h2><h2 id="83-前K个高频元素"><a href="#83-前K个高频元素" class="headerlink" title="83. 前K个高频元素"></a>83. 前K个高频元素</h2><p><img src="/img/leetcode/1678019162639-cbb2c10e-2187-4aee-834f-170e10a63985.png"></p><p>首先用hashmap记录每个元素的出现次数，然后构建一个尺寸为k的小顶堆，不然不限制尺寸的话时间复杂度为O(nlogn)，限制尺寸的话时间复杂度为O(nlogk)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; fre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            fre.put(num, fre.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : fre.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span>(q.size() != k) &#123;<br>                q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(q.peek()[<span class="hljs-number">1</span>] &lt; entry.getValue()) &#123;<br>                    q.poll();<br>                    q.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[q.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; res.length; ++i) &#123;<br>            res[i] = q.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="84-字符串解码"><a href="#84-字符串解码" class="headerlink" title="84. 字符串解码**"></a>84. 字符串解码**</h2><h2 id="85-除法求值"><a href="#85-除法求值" class="headerlink" title="85. 除法求值**"></a>85. 除法求值**</h2><h2 id="86-根据身高重建队列"><a href="#86-根据身高重建队列" class="headerlink" title="86. 根据身高重建队列**"></a>86. 根据身高重建队列**</h2><h2 id="87-分割等和子集"><a href="#87-分割等和子集" class="headerlink" title="87. 分割等和子集"></a>87. 分割等和子集</h2><p><img src="/img/leetcode/1678015187472-515428a4-61f5-4360-b155-eee1509ed5d3.png"></p><p>动态规划，dp[i][j]表示从0到i能否选取数字得到j。</p><p>初始化，dp[i][0]为true。dp[i][nums[i]]为true。当j小于nums[i]，说明nums[i]不可取，所以dp[i][j] &#x3D; dp[i - 1][j]；否则，nums[i]可取可不取，所以dp[i][j] &#x3D; dp[i - 1][j] || dp[i - 1][j - nums[i]]。</p><p>因为涉及i - 1，所以i从1开始遍历，所以需要初始化dp[i][nums[i]]。</p><p>需要注意nums[i]可能超过sum&#x2F;2，此时初始化会越界，因此要排除这种情况，这种情况直接return false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>            max = Math.max(num, max);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(max &gt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(j &lt; nums[i]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="88-路径总和III"><a href="#88-路径总和III" class="headerlink" title="88. 路径总和III"></a>88. 路径总和III</h2><p><img src="/img/leetcode/1678013919262-0d038661-806f-4695-b31c-91e2ede811ee.png"></p><p>先写一个方法，可以找到从某个节点开始搜索得到的路径树，然后遍历二叉树的所有节点即可。</p><p>防止超出int范围，将rootSum中的sum数据类型改为long</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> rootSum(root, targetSum);<br>        ret += pathSum(root.left, targetSum);<br>        ret += pathSum(root.right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rootSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> root.val;<br>        <span class="hljs-keyword">if</span> (val == targetSum) &#123;<br>            ret++;<br>        &#125; <br><br>        ret += rootSum(root.left, targetSum - val);<br>        ret += rootSum(root.right, targetSum - val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="89-找到字符串中所有字母异位词"><a href="#89-找到字符串中所有字母异位词" class="headerlink" title="89. 找到字符串中所有字母异位词**"></a>89. 找到字符串中所有字母异位词**</h2><h2 id="90-找到所有数组中消失的数字"><a href="#90-找到所有数组中消失的数字" class="headerlink" title="90. 找到所有数组中消失的数字**"></a>90. 找到所有数组中消失的数字**</h2><h2 id="91-汉明距离"><a href="#91-汉明距离" class="headerlink" title="91. 汉明距离**"></a>91. 汉明距离**</h2><h2 id="92-目标和"><a href="#92-目标和" class="headerlink" title="92. 目标和**"></a>92. 目标和**</h2><h2 id="93-把二叉搜索树转换为累加树"><a href="#93-把二叉搜索树转换为累加树" class="headerlink" title="93. 把二叉搜索树转换为累加树**"></a>93. 把二叉搜索树转换为累加树**</h2><h2 id="94-二叉树的直径"><a href="#94-二叉树的直径" class="headerlink" title="94. 二叉树的直径**"></a>94. 二叉树的直径**</h2><h2 id="95-和为K的子数组"><a href="#95-和为K的子数组" class="headerlink" title="95. 和为K的子数组"></a>95. 和为K的子数组</h2><p><img src="/img/leetcode/1677987256995-9635ffa9-5851-45b6-b1d5-6edfd2c6c20b.png"></p><p>滑动窗口，不能是滑动窗口，nums中的数值可能是负数！</p><p>前缀和，从前往后遍历，用map记录下不同前缀和的数量，当遍历到一个元素时，使用map.get(pre - k)即可找到该位置所能匹配的子数组个数。</p><p>注意初始的时候要map.put(0, 1)，这是初始情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            pre += nums[i];<br>            res += map.getOrDefault(pre - k, <span class="hljs-number">0</span>);<br>            map.put(pre, map.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="96-最短无序连续子数组"><a href="#96-最短无序连续子数组" class="headerlink" title="96. 最短无序连续子数组"></a>96. 最短无序连续子数组</h2><p><img src="/img/leetcode/1677985974509-c966afb1-d9e3-4bb3-82b8-35e1b58e18c3.png"></p><p>暴力，将数组排序后，比较左边第一个不一致的下标和右边第一个不一致的下标，即可得出最短无序子数组。</p><p>根据左边有序区间所有数都小于右边，右边有序区间所有数都大于左边，可以遍历更新得到两个边界。</p><p>还需要注意判断数组本来就有序，即right或者left &#x3D;&#x3D; -1，此时返回0；否则返回right - left + 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, min = Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, right = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(max &gt; nums[i]) &#123;<br>                right = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(min &lt; nums[n - i - <span class="hljs-number">1</span>]) &#123;<br>                left = n - i - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                min = nums[n - i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left == -<span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : right - left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="97-合并二叉树"><a href="#97-合并二叉树" class="headerlink" title="97. 合并二叉树**"></a>97. 合并二叉树**</h2><h2 id="98-任务调度器"><a href="#98-任务调度器" class="headerlink" title="98. 任务调度器**"></a>98. 任务调度器**</h2><h2 id="99-回文子串"><a href="#99-回文子串" class="headerlink" title="99. 回文子串"></a>99. 回文子串</h2><p><img src="/img/leetcode/1677984554179-b48f4887-53fd-443b-9f83-e42cfc559d70.png"></p><p>动态规划！用dp[i][j]表示以i和j作为下标的子串是否回文。</p><p>当i和j位置的字符一致时，检查当i和j相差1或2时，回文，设为true。其实2不用判断，因为根据下面的逻辑，此时会被设为true。</p><p>如果i和j相差超过1，则dp[i][j] &#x3D; dp[i - 1][j - 1]。</p><p>这里要注意遍历的顺序，比如dp[0][4]要借助于正确的dp[1][3]。</p><p>如果正向遍历的话，第一次循环中0比1要早，那么此时dp[1][3]还没有被计算会出错，因此要从后往前遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>            ++res;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(j) == s.charAt(i)) &#123;<br>                    <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">2</span>) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        ++res;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(dp[i][j]) &#123;<br>                            ++res;<br>                        &#125;<br>                    &#125;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="100-每日温度"><a href="#100-每日温度" class="headerlink" title="100. 每日温度**"></a>100. 每日温度**</h2><h2 id="101-K-个一组翻转链表"><a href="#101-K-个一组翻转链表" class="headerlink" title="101.K 个一组翻转链表"></a>101.K 个一组翻转链表</h2><p><img src="/img/leetcode/1693969748616-aa59e1e1-dc3a-43c9-a388-2368ce69bfb5.png"></p><p>每个组内进行翻转，此时翻转逻辑和之前的不一致，因为结束条件不是cur  !&#x3D; null</p><p>同时每个组内翻转之后，头尾节点要和链表中的其他部分相连</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> pre;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                tail = tail.next;<br>                <span class="hljs-keyword">if</span>(tail == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> dummy.next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> tail.next;<br>            ListNode[] rec = reverse(head, tail);<br>            pre.next = rec[<span class="hljs-number">0</span>];<br>            rec[<span class="hljs-number">1</span>].next = next;<br>            pre = rec[<span class="hljs-number">1</span>];<br>            head = pre.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 和之前的反转逻辑不太一样，因为这里结束条件不一样了</span><br>    <span class="hljs-keyword">private</span> ListNode[] reverse(ListNode head, ListNode tail) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> tail.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(pre != tail) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>[]&#123;tail, head&#125;;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="102-比较版本号"><a href="#102-比较版本号" class="headerlink" title="102.比较版本号"></a>102.比较版本号</h2><p><img src="/img/leetcode/1694441539588-e9d5714a-ce83-41d3-ac84-3e04e591fe31.png"></p><p>利用split方法，注意转义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareVersion</span><span class="hljs-params">(String version1, String version2)</span> &#123;<br>        List&lt;Integer&gt; v1 = getVersions(version1);<br>        List&lt;Integer&gt; v2 = getVersions(version2);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.max(v1.size(), v2.size()); i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, num2 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(i &lt; v1.size()) &#123;<br>                num1 = v1.get(i);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; v2.size()) &#123;<br>                num2 = v2.get(i);<br>            &#125;          <br>            <span class="hljs-keyword">if</span>(num1 &gt; num2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num1 &lt; num2) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">getVersions</span><span class="hljs-params">(String version)</span> &#123;<br>        String[] versions = version.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String s : versions) &#123;<br>            <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(idx &lt; cs.length &amp;&amp; cs[idx] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                idx++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> idx; i &lt; cs.length; i++) &#123;<br>                cur *= <span class="hljs-number">10</span>;<br>                cur += cs[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            list.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="103-二叉树中的最大路径和"><a href="#103-二叉树中的最大路径和" class="headerlink" title="103.二叉树中的最大路径和"></a>103.二叉树中的最大路径和</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/leetcode/1694504160314-686655eb-f06e-431a-b472-29a1f33d91e5.png"></h2><p>dfs递归，递归返回的是以当前节点为起点和根节点，所能得到的最大路径和。因此最大路径和就是当前节点的值，再加上左右子节点的最大路径和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Math.max(dfs(root.left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Math.max(dfs(root.right), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root.val + l + r;<br>        max = Math.max(cur, max);<br><br>        <span class="hljs-keyword">return</span> root.val + Math.max(l, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h2 id="1-整数除法"><a href="#1-整数除法" class="headerlink" title="1. 整数除法"></a>1. 整数除法</h2><p><img src="/img/leetcode/1679804701657-23341783-0a25-4867-a80a-adfaac9f6bf7.png"></p><p>有几个需要注意的点：</p><ol><li>当被除数是Integer.MIN_VALUE时，如果除数是-1，此时会溢出。因此需要特殊判断。</li><li>当除数是Integer.MIN_VALUE时，进行特殊判断。</li><li>当被除数是0时，直接返回0。</li><li>为了统一，把除数和被除数都转换为负数，用rev的boolean类型记录几个数取反了，后续return结果时要相应取反或者不取反。为什么不转换为正数，因为Integer.MIN_VALUE取反后会溢出。</li><li>用二分法+快速加的思路找到对应的结果。其中还是有些细节需要注意的，详见代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span>(a == Integer.MIN_VALUE) &#123;<br>            <span class="hljs-keyword">if</span>(b == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>            &#125; <br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b == Integer.MIN_VALUE) &#123;<br>            <span class="hljs-keyword">if</span>(a == Integer.MIN_VALUE) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">rev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span>) &#123;<br>            a = -a;<br>            rev = !rev;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(b &gt; <span class="hljs-number">0</span>) &#123;<br>            b = -b;<br>            rev = !rev;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, right = Integer.MAX_VALUE, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> quickadd(a, b, mid);<br>            <span class="hljs-keyword">if</span>(flag) &#123;<br>                ans = mid;<br>                <span class="hljs-comment">// 此时说明ans就是最大值，直接break，否则后续left会溢出</span><br>                <span class="hljs-keyword">if</span>(mid == Integer.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rev ? -ans : ans;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 不能一直累加到y*mid，这样可能溢出，因此需要在每次加的时候都进行判断！</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">quickadd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> mid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(mid != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>((mid &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 判断加上add之后res会不会比x更小</span><br>                <span class="hljs-keyword">if</span>(res &lt; x - add) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                res += add;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 此时要翻倍add，需要判断add + add会不会比x更小，且防止add的溢出</span><br>            <span class="hljs-comment">// 当mid为1时不需要再判断，因为后续不再执行add + add操作了 </span><br>            <span class="hljs-keyword">if</span>(mid != <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span>(add &lt; x - add) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                add += add;<br>            &#125;<br>            mid &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-二进制加法"><a href="#2-二进制加法" class="headerlink" title="2. 二进制加法"></a>2. 二进制加法</h2><p><img src="/img/leetcode/1679805222079-77aef32c-3039-4aed-9cb0-66b36b813662.png"></p><p>先反转a和b，然后相加，最后反转得到结果。</p><p>每次append后都要更新over，而不仅仅是over&#x3D;1的时候才更新。</p><p>直接遍历到两者的最大长度，而不是遍历到最小长度，如果某个字符串越界了直接赋值为0.</p><p>别忘了最后可能还需要append一个1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addBinary</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-comment">// 先反转，再累加，再反转得到结果</span><br>        <span class="hljs-comment">// 每次append之后都要更新over，不然前一个over = 1，不更新over会对后续产生影响</span><br>        <span class="hljs-comment">// 直接遍历到两者的最大值为止，如果越界了则赋值为0</span><br>        <span class="hljs-comment">// 别忘了最后还可能需要append一个&#x27;1&#x27;</span><br>        <span class="hljs-type">char</span>[] newA = reverse(a);<br>        <span class="hljs-type">char</span>[] newB = reverse(b);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idxA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, idxB = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">over</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(idxA &lt; a.length() || idxB &lt; b.length()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, numB = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(idxA &lt; a.length()) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">cA</span> <span class="hljs-operator">=</span> newA[idxA];<br>                numA = cA - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(idxB &lt; b.length()) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">cB</span> <span class="hljs-operator">=</span> newB[idxB];<br>                numB = cB - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">// System.out.println(numA);</span><br>            <span class="hljs-comment">// System.out.println(numB);</span><br>            <span class="hljs-keyword">if</span>(numA + numB + over == <span class="hljs-number">2</span>) &#123;<br>                sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>                over = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numA + numB + over == <span class="hljs-number">1</span>) &#123;<br>                sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>                over = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numA + numB + over == <span class="hljs-number">3</span>)&#123;<br>                sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>                over = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>                over = <span class="hljs-number">0</span>;<br>            &#125;<br>            ++idxA;<br>            ++idxB;<br>            <span class="hljs-comment">// System.out.println(sb.toString());</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(over == <span class="hljs-number">1</span>) &#123;<br>            sb.append(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(reverse(sb.toString()));<br>    &#125;<br><br><br>    <span class="hljs-type">char</span>[] reverse(String s) &#123;<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(a &lt; b) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cs[a];<br>            cs[a] = cs[b];<br>            cs[b] = temp;<br>            ++a;<br>            --b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cs;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-前n个数字二进制中1的个数"><a href="#3-前n个数字二进制中1的个数" class="headerlink" title="3. 前n个数字二进制中1的个数"></a>3. 前n个数字二进制中1的个数</h2><p><img src="/img/leetcode/1679805414037-1f4b19bc-22e0-40e3-b1e6-436823653c20.png"></p><p>方法1：直接遍历每个元素的二进制位，然后算出1的个数即可。时间复杂度较高。</p><p>方法2：x &amp; (x - 1)可以将x的最后一个为1的二进制位设置为0。因此可以得到状态转移方程</p><p>dp[i] &#x3D; dp[i &amp; (i - 1)] + 1</p><p>时间复杂度更小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 遍历元素的每个二进制位计算1的个数</span><br>        <span class="hljs-comment">// int[] res = new int[n + 1];</span><br>        <span class="hljs-comment">// for(int i = 0; i &lt;= n; ++i) &#123;</span><br>        <span class="hljs-comment">//     res[i] = count(i);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return res;</span><br><br><br>        <span class="hljs-comment">// i &amp; (i - 1)可以将i中最后一个1改为0，因此该dp状态转移方程成立</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            res[i] = res[i &amp; (i - <span class="hljs-number">1</span>)] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br><br>    &#125;<br><br><br>    <span class="hljs-comment">// int count(int a) &#123;</span><br>    <span class="hljs-comment">//     int res = 0;</span><br>    <span class="hljs-comment">//     while(a != 0) &#123;</span><br>    <span class="hljs-comment">//         if((a &amp; 1) != 0) &#123;</span><br>    <span class="hljs-comment">//             ++res;</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//         a &gt;&gt;= 1;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">//     return res;</span><br>    <span class="hljs-comment">// &#125;</span><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-只出现一次的数字"><a href="#4-只出现一次的数字" class="headerlink" title="4. 只出现一次的数字"></a>4. 只出现一次的数字</h2><p><img src="/img/leetcode/1679805593031-5329cfc0-ac97-477b-931d-0bef9a1eb340.png"></p><ol><li>哈希表记录出现频率</li><li>计算答案的每一个二进制位，即对每个二进制位进行相加，对3取余，结果就是答案在该二进制位的数值，时间复杂度nlogC，logC是数字的二进制位数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>                sum += ((num &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> sum % <span class="hljs-number">3</span>;<br>            res |= ((val) &lt;&lt; i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>方法2中对每个二进制位都进行了n次遍历，那么可否直接进行二元计算来得到最终的结果，让时间复杂度变为n。可以用a和b两个数来存储结果，a和b的组合可以代表每个二进制位当前相加余3的结果。为什么需要a和b两个字母，因为余3的结果可能有0，1，2。需要有两个数字才能表示。因此当ab为00，表示取余结果为0，01表示取余结果为1，10表示取余结果为2。10只会在中间过程中出现，最后结果ab只可能是00或者01。因此ab的转变顺序为00 -&gt; 01 -&gt; 10 -&gt; 00 -&gt; …. 最后直接return b即可，因为b&#x3D;0，表示该二进制位为0；b&#x3D;1，表示该二进制位为1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            b = ~a &amp; (b ^ num);<br>            a = ~b &amp; (a ^ num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-单词长度的最大乘积"><a href="#5-单词长度的最大乘积" class="headerlink" title="5. 单词长度的最大乘积"></a>5. 单词长度的最大乘积</h2><p><img src="/img/leetcode/1679807171601-d230ace5-c180-492d-929d-134f018788f2.png"></p><p>首先找到满足要求的两个字符串的长度乘积最大值，O(n^2)的时间复杂度是至少的，需要遍历不同的字符串组合进行判断。重点在于不同字符串是否包含相同字符，如果采用传统的方法，时间复杂度和空间复杂度可能过高。可以采取位运算的方式来判断，全部都是小写字母，因此构建一个数字，其中0-25位分别表示’a’-‘z’是否出现在该字符串中，然后对两个字符串的二进制进行与操作即可判断，只有当与的结果为0，表示无相同字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">int</span>[] masks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[words.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; masks.length; ++i) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; word.length(); ++j) &#123;<br>                masks[i] |= (<span class="hljs-number">1</span> &lt;&lt; (word.charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; masks.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; masks.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span>((masks[i] &amp; masks[j]) == <span class="hljs-number">0</span>) &#123;<br>                    res = Math.max(res, words[i].length() * words[j].length());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-排序数组中两个数字之和"><a href="#6-排序数组中两个数字之和" class="headerlink" title="6. 排序数组中两个数字之和"></a>6. 排序数组中两个数字之和</h2><p><img src="/img/leetcode/1679810919708-e20c5771-d5b3-4ffc-98cf-f067b6a67b48.png"></p><ol><li>利用排序数组的性质，遍历第一个元素的下标，然后二分法找第二个元素。时间复杂度O(nlogn)</li><li>双指针，左右指针分别指向两端，可以证明不会错过答案</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[l] + numbers[r];<br>            <span class="hljs-keyword">if</span>(sum == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l, r&#125;;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) &#123;<br>                --r;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-数组中和为0的三个数"><a href="#7-数组中和为0的三个数" class="headerlink" title="7. 数组中和为0的三个数"></a>7. 数组中和为0的三个数</h2><p><img src="/img/leetcode/1679811142138-234eeaf9-1eda-454c-93a5-683ee85ff479.png"></p><p>排序+双指针</p><p>排序之后一方面可以解决重复的问题，当遍历的当前元素与之前的元素相同时，continue</p><p>通过排序+双指针，可以将O(n^2)的时间复杂度降为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> - nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span>(j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(r &gt; j &amp;&amp; nums[r] + nums[j] &gt; target) &#123;<br>                    --r;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(r &gt; j &amp;&amp; nums[r] + nums[j] == target) &#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    list.add(nums[i]);<br>                    list.add(nums[j]);<br>                    list.add(nums[r]);<br>                    res.add(list);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-和大于等于target的最短子数组"><a href="#8-和大于等于target的最短子数组" class="headerlink" title="8. 和大于等于target的最短子数组"></a>8. 和大于等于target的最短子数组</h2><p><img src="/img/leetcode/1679898750590-8d230969-05ee-40ab-af67-1b0c84e58dc9.png"></p><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span>(r &lt; nums.length) &#123;<br>            sum += nums[r];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target) &#123;<br>                res = Math.min(res, r - l + <span class="hljs-number">1</span>);<br>                sum -= nums[l];<br>                ++l;<br>            &#125;<br>            ++r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == Integer.MAX_VALUE ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-乘积小于K的子数组"><a href="#9-乘积小于K的子数组" class="headerlink" title="9. 乘积小于K的子数组"></a>9. 乘积小于K的子数组</h2><p><img src="/img/leetcode/1679811885397-92144739-d862-4344-8605-ff57465d0269.png"></p><p>不适合用前缀，会溢出。</p><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayProductLessThanK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">multi</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; nums.length) &#123;<br>            multi *= nums[r];<br>            <span class="hljs-keyword">while</span>(multi &gt;= k &amp;&amp; l &lt;= r) &#123;<br>                multi /= nums[l];<br>                ++l;<br>            &#125;<br>            res += r - l + <span class="hljs-number">1</span>;<br>            ++r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-和为k的子数组"><a href="#10-和为k的子数组" class="headerlink" title="10. 和为k的子数组"></a>10. 和为k的子数组</h2><p><img src="/img/leetcode/1679899995317-c9ed1537-b937-4e4a-b170-4b7ea446184f.png"></p><p>不能用滑动窗口，数组中的数值可能为负！</p><p>前缀和+哈希，注意最开始要map.put(0, 1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            pre += nums[i];<br>            res += map.getOrDefault(pre - k, <span class="hljs-number">0</span>);<br>            map.put(pre, map.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-0和1个数相同的子数组"><a href="#11-0和1个数相同的子数组" class="headerlink" title="11. 0和1个数相同的子数组"></a>11. 0和1个数相同的子数组</h2><p><img src="/img/leetcode/1679902221359-d5cc54a2-a993-4c46-8374-9dc095bdde5c.png"></p><p>前缀和+哈希</p><p>所求的是最大连续子数组长度，因此val要保存下标</p><p>同样要mao.put(0, -1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        map.put(counter, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                counter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.containsKey(counter)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> map.get(counter);<br>                maxLength = Math.max(maxLength, i - prevIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(counter, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-左右两边子数组的和相等"><a href="#12-左右两边子数组的和相等" class="headerlink" title="12. 左右两边子数组的和相等"></a>12. 左右两边子数组的和相等</h2><p><img src="/img/leetcode/1679902751671-6b544f05-4fe2-4203-876a-3b81d9a91afc.png"></p><p>前缀和，用于快速计算两区间内的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; ++i) &#123;<br>            pre[i] = pre[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> pre[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> pre[nums.length] - pre[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(left == right) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-二维子矩阵的和"><a href="#13-二维子矩阵的和" class="headerlink" title="13. 二维子矩阵的和"></a>13. 二维子矩阵的和</h2><p><img src="/img/leetcode/1679904071244-f5aed0cb-707c-421b-a14d-8120a368f925.png"></p><p>前缀和，需要注意前缀和最好还是在原本的基础上多加一行&#x2F;一列，用来表示基准。</p><p>不然对于一些操作不具有普遍性。</p><p>下面这个操作中前缀和数组和原数组维度一样，导致一些操作不够统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><br><br>    <span class="hljs-type">int</span>[][] pre;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        pre[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            pre[<span class="hljs-number">0</span>][j] = pre[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + matrix[<span class="hljs-number">0</span>][j];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            pre[i][<span class="hljs-number">0</span>] = pre[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + matrix[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] + pre[i][j - <span class="hljs-number">1</span>] - pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + matrix[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(col1 &gt; <span class="hljs-number">0</span>) &#123;<br>            sum1 = pre[row2][col1 - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row1 &gt; <span class="hljs-number">0</span>) &#123;<br>            sum2 = pre[row1 - <span class="hljs-number">1</span>][col2];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(row1 &gt; <span class="hljs-number">0</span> &amp;&amp; col1 &gt; <span class="hljs-number">0</span>) &#123;<br>            sum3 = pre[row1 - <span class="hljs-number">1</span>][col1 - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre[row2][col2] - (sum1 + sum2 - sum3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-字符串中的变位词"><a href="#14-字符串中的变位词" class="headerlink" title="14. 字符串中的变位词"></a>14. 字符串中的变位词</h2><p><img src="/img/leetcode/1679904301453-d1cf6b21-955b-4c48-9b62-649c551872f1.png"></p><p>依次比较s2中各个长度等于s1的子串是否是变位词即可，用数组记录子串中各字母的数量。</p><p>每次遍历时只需要更新两个位置的数值。</p><p>相当于滑动窗口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s1.length() &gt; s2.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] rec1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] rec2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s1.toCharArray()) &#123;<br>            rec1[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s1.length(); ++i) &#123;<br>            rec2[s2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(rec1, rec2)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s1.length(); i &lt; s2.length(); ++i) &#123;<br>            rec2[s2.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            rec2[s2.charAt(i - s1.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(rec1, rec2)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-字符串中的所有变位词"><a href="#15-字符串中的所有变位词" class="headerlink" title="15. 字符串中的所有变位词"></a>15. 字符串中的所有变位词</h2><p><img src="/img/leetcode/1679985008190-b03913ed-29e3-4b79-92e8-9da1df41b7b0.png"></p><p>同上，滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(s.length() &lt; p.length()) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span>[] recP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : p.toCharArray()) &#123;<br>            recP[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-type">int</span>[] recS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            recS[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(recS, recP)) &#123;<br>            res.add(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); ++i) &#123;<br>            recS[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            recS[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(recS, recP)) &#123;<br>                res.add(i - p.length() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-不含重复字符的最长子字符串"><a href="#16-不含重复字符的最长子字符串" class="headerlink" title="16. 不含重复字符的最长子字符串"></a>16. 不含重复字符的最长子字符串</h2><p><img src="/img/leetcode/1680333871754-7d90d447-4698-445d-ab6f-bbc590061b59.png"></p><p>滑动窗口，可以证明某些遍历是不必要的， 因此用滑动窗口即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; s.length()) &#123;<br>            <span class="hljs-keyword">if</span>(set.add(s.charAt(r))) &#123;<br>                res = Math.max(res, r - l + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(s.charAt(l) != s.charAt(r)) &#123;<br>                    set.remove(s.charAt(l));<br>                    ++l;<br>                &#125;<br>                ++l;<br>            &#125;<br>            ++r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-含有所有字符的最短字符串"><a href="#17-含有所有字符的最短字符串" class="headerlink" title="17. 含有所有字符的最短字符串"></a>17. 含有所有字符的最短字符串</h2><p><img src="/img/leetcode/1680334768434-6926cee1-50f3-4ae2-86b3-dafcfcf28a05.png"></p><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, len = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span>(s.length() &lt; t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(r &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> s.charAt(r);<br>            <span class="hljs-keyword">if</span>(map.containsKey(cur)) &#123;<br>                map.put(cur, map.get(cur) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(checked(map)) &#123;<br>                <span class="hljs-keyword">if</span>(len &gt; r - l + <span class="hljs-number">1</span>) &#123;<br>                    start = l;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> s.charAt(l);<br>                <span class="hljs-keyword">if</span>(map.containsKey(left)) &#123;<br>                    map.put(left, map.get(left) + <span class="hljs-number">1</span>);<br>                &#125;<br>                ++l;<br>            &#125;<br>            ++r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checked</span><span class="hljs-params">(Map&lt;Character, Integer&gt; map)</span> &#123;<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-keyword">if</span>(entry.getValue() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-有效的回文"><a href="#18-有效的回文" class="headerlink" title="18. 有效的回文"></a>18. 有效的回文</h2><p><img src="/img/leetcode/1680335417197-afd8d4a8-4c9d-4703-b656-2ab86f972de5.png"></p><p>提取新的字符串，并且双指针判断是否回文。</p><p>一些Character的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(Character.isLetterOrDigit(c)) &#123;<br>                sb.append(Character.toLowerCase(c));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = sb.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">if</span>(sb.charAt(l) != sb.charAt(r)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            ++l;<br>            --r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-最多删除一个字符得到回文"><a href="#19-最多删除一个字符得到回文" class="headerlink" title="19. 最多删除一个字符得到回文"></a>19. 最多删除一个字符得到回文</h2><p><img src="/img/leetcode/1680336250727-bbba1dcf-b105-4e44-aca5-5c77e220f6ff.png"></p><p>双指针进行判断，当遇到不一致时，可能有两种情况，此时这两种情况下有一种为回文，则为回文，所有用||操作即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(l) == s.charAt(r)) &#123;<br>                ++l;<br>                --r;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                flag = checked(s, l + <span class="hljs-number">1</span>, r) || checked(s, l, r - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">checked</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(left) != s.charAt(right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            ++left;<br>            --right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-回文子字符串的个数"><a href="#20-回文子字符串的个数" class="headerlink" title="20. 回文子字符串的个数"></a>20. 回文子字符串的个数</h2><p><img src="/img/leetcode/1680340105745-b6d2d958-7631-4fa3-a2ed-18f61f5e801d.png"></p><p>动态规划，需要注意i的遍历顺序，因为状态转移方程中依赖于i + 1，因此i要从大遍历到小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>           dp[i][i] = <span class="hljs-literal">true</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); ++j) &#123;<br>               <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;<br>                   <span class="hljs-keyword">if</span>(j - i &lt;= <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                       dp[i][j] = <span class="hljs-literal">true</span>;<br>                   &#125;<br>                   <span class="hljs-keyword">if</span>(dp[i][j]) &#123;<br>                       ++res;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-删除链表的倒数第n个结点"><a href="#21-删除链表的倒数第n个结点" class="headerlink" title="21. 删除链表的倒数第n个结点"></a>21. 删除链表的倒数第n个结点</h2><p><img src="/img/leetcode/1680340233903-13996812-62f6-45dc-8b9c-2af2f2f07d4f.png"></p><p>双指针，让快指针先走，慢指针后走，慢指针到达要删除结点的前一个结点位置即可。</p><p>注意设置dummy头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">0</span>) &#123;<br>            fast = fast.next;<br>            --n;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-链表中环的入口节点"><a href="#22-链表中环的入口节点" class="headerlink" title="22. 链表中环的入口节点"></a>22. 链表中环的入口节点</h2><p><img src="/img/leetcode/1680483683107-2352e40c-5c83-4a81-9261-3dbea956964a.png"></p><p>双指针，注意fast指针指向head后，每次跳一个，而不是跳两个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <br>        &#125;<br>        fast = head;<br>        <span class="hljs-keyword">while</span>(fast != slow) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-两个链表的第一个重合节点"><a href="#23-两个链表的第一个重合节点" class="headerlink" title="23. 两个链表的第一个重合节点"></a>23. 两个链表的第一个重合节点</h2><p><img src="/img/leetcode/1680484232987-21ca9a6a-872c-4cce-b6ee-3add4ded097f.png"></p><p>双指针，当到null时，将指针指向另一个链表的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-keyword">while</span>(a != b) &#123;<br>            <span class="hljs-keyword">if</span>(a == <span class="hljs-literal">null</span>) &#123;<br>                a = headB;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a = a.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-literal">null</span>) &#123;<br>                b = headA;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b = b.next;<br>            &#125;<br>                     <br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h2><p><img src="/img/leetcode/1680485067205-5dc8aec5-379c-4a20-8c3e-80cffd28695d.png"></p><p>用三个指针记录节点，注意prev从null开始，cur从head开始，这样头结点的next节点才是null，否则会出现环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-链表中的两数相加"><a href="#25-链表中的两数相加" class="headerlink" title="25. 链表中的两数相加"></a>25. 链表中的两数相加</h2><p><img src="/img/leetcode/1680485446591-ee872d96-1915-4cf9-a299-07e79f162380.png"></p><p>先对两个链表进行反转，然后遍历创建新的链表，然后反转。</p><p>注意最后一个over！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> reverse(l1);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> reverse(l2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">over</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span>(a != <span class="hljs-literal">null</span> || b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">valA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, valB = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(a != <span class="hljs-literal">null</span>) &#123;<br>                valA = a.val;<br>                a = a.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(b != <span class="hljs-literal">null</span>) &#123;<br>                valB = b.val;<br>                b = b.next;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> valA + valB + over;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            cur = cur.next;<br>            over = sum / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(over != <span class="hljs-number">0</span>) &#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(over);<br>        &#125;<br>        <span class="hljs-keyword">return</span> reverse(dummy.next);<br>    &#125;<br><br><br>    ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-重排链表"><a href="#26-重排链表" class="headerlink" title="26. 重排链表"></a>26. 重排链表</h2><p><img src="/img/leetcode/1680485952487-e4a3c490-226a-434a-b1a1-463bb8972a85.png"></p><p>首先将链表分成两部分，对后面的链表进行反转，然后合并两个链表</p><p>注意要把slow的next置为null，while循环中fast.next.next !&#x3D; null，这样遍历slow才会指向中点的前一个节点，然后才能将slow.next置为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> reverse(b);<br><br><br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(flag) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            flag = !flag;<br>            cur = cur.next;<br>        &#125;<br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>    &#125;<br><br><br>    ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-回文链表"><a href="#27-回文链表" class="headerlink" title="27. 回文链表"></a>27. 回文链表</h2><p><img src="/img/leetcode/1680487454619-93934328-7559-4aa6-b785-bc1d4cbcdcf0.png"></p><p>同上，反转后半部分链表，然后判断是否回文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> reverse(slow.next);<br>        <span class="hljs-keyword">while</span>(l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(head.val != l2.val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            l2 = l2.next;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-展平多级双向链表"><a href="#28-展平多级双向链表" class="headerlink" title="28. 展平多级双向链表"></a>28. 展平多级双向链表</h2><p><img src="/img/leetcode/1680572213561-3026033f-9cb1-44de-b112-b4283ddd96e0.png"></p><p>深度优先搜索，需要注意几个细节。</p><p>1）第一个节点的prev会指向dummy，需要设置为null</p><p>2）有child的节点，在dfs之后，需要把child置为null</p><p>3）需要用temp存head.next，否则dfs后head.next已经发生了变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">flatten</span><span class="hljs-params">(Node head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        dfs(head);<br>        dummy.next.prev = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(Node head)</span> &#123;<br><br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = head;<br>            head.prev = cur;<br>            cur = cur.next;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>            <span class="hljs-keyword">if</span>(head.child != <span class="hljs-literal">null</span>) &#123;<br>                dfs(head.child);<br>            &#125;<br>            head.child = <span class="hljs-literal">null</span>;<br>            head = temp;<br>        &#125;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-排序的循环链表"><a href="#29-排序的循环链表" class="headerlink" title="29. 排序的循环链表"></a>29. 排序的循环链表</h2><p><img src="/img/leetcode/1680573323111-27e4220d-95e4-4678-8fba-34fe45c2de06.png"></p><p>模拟，需要注意</p><p>1）head为null时，创建一个循环链表，节点的next是该节点本身</p><p>2）判断插入位置，第一种是处在prev和after之间，另一种是插入的元素最大或者最小</p><p>3）向一个唯一节点的循环链表插入元素，需要进行额外判断</p><p>4）循环链表元素都一致</p><p>while循环，循环条件是next!&#x3D;head，如果next等于head，说明遍历了全部还是找不到插入位置，这时候肯定是插入在head之前的一个位置。while循环中判断是否可以插入，首先判断插入元素是否在prev和after之间，如果是break。然后当after小于prev时，说明遇到了最小值，判断插入元素是否大于prev或者小于after，如果是，break。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> insertVal)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>            node.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head.next == head) &#123;<br>            head.next = node;<br>            node.next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-keyword">while</span>(next != head) &#123;<br>   <br>            <span class="hljs-keyword">if</span>(insertVal &gt;= cur.val &amp;&amp; insertVal &lt;= next.val) &#123;<br>                <span class="hljs-keyword">break</span>;            <br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(cur.val &gt; next.val) &#123;<br>                <span class="hljs-keyword">if</span>(insertVal &gt;= cur.val || insertVal &lt;= next.val) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            cur = cur.next;<br>            next = next.next;<br>        &#125;<br>        node.next = cur.next;<br>        cur.next = node;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="30-插入、删除和随机访问都是O-1-的容器"><a href="#30-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="30. 插入、删除和随机访问都是O(1)的容器"></a>30. 插入、删除和随机访问都是O(1)的容器</h2><p><img src="/img/leetcode/1680575456712-3134ffb7-4ed2-4b10-b213-80cbec0794eb.png"></p><p>链表可以做到O(1)时间复杂度访问元素，map可以做到O(1)时间复杂度插入删除元素</p><p>因此结合链表和哈希表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br><br><br>    List&lt;Integer&gt; list;<br>    Map&lt;Integer, Integer&gt; map;<br>    Random random;<br><br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomizedSet</span><span class="hljs-params">()</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;   <br>    <br>    <span class="hljs-comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        list.add(val);<br>        map.put(val, list.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> map.get(val);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastVal</span> <span class="hljs-operator">=</span> list.get(list.size() - <span class="hljs-number">1</span>);<br>        list.set(idx, lastVal);<br>        list.remove(list.size() - <span class="hljs-number">1</span>);<br>        map.put(lastVal, idx);<br>        map.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get a random element from the set. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.get(random.nextInt(list.size()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-最近最少使用缓存（LRU）"><a href="#31-最近最少使用缓存（LRU）" class="headerlink" title="31. 最近最少使用缓存（LRU）"></a>31. 最近最少使用缓存（LRU）</h2><p><img src="/img/leetcode/1680757633187-df59069c-5024-4c71-9016-8fb9ffee13b5.png"></p><p>哈希表+双向链表，哈希表记录位置用来实现O(1)的时间复杂度</p><p>注意用head和tail表示虚拟的头、尾节点，不是真正的头尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> val;<br>        Node prev;<br>        Node next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br>    &#125;<br><br><br>    Map&lt;Integer, Node&gt; map;<br>    Node head;<br>    Node tail;<br>    <span class="hljs-type">int</span> capacity;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>        removeAndAdd(node);<br>        <span class="hljs-keyword">return</span> node.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);<br>            removeAndAdd(node);<br>            node.val = value;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>            <span class="hljs-keyword">if</span>(map.size() &lt; capacity) &#123;                        <br>                addToHead(node);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tailKey</span> <span class="hljs-operator">=</span> tail.prev.key;<br>                removeTail();<br>                addToHead(node);<br>                map.remove(tailKey);<br>            &#125;<br>            map.put(key, node);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAndAdd</span><span class="hljs-params">(Node node)</span> &#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> tail.prev;<br>        removeNode(temp);<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="32-有效的变位词"><a href="#32-有效的变位词" class="headerlink" title="32. 有效的变位词"></a>32. 有效的变位词</h2><p><img src="/img/leetcode/1680764337329-8e091db3-7e8d-4273-bb07-9ed1ded1878a.png"></p><p>用26长度的int数组记录两个字符串的字符出现次数，需要注意最后return !s.equals(t)，当顺序完全一致时也不是有效的变位词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span>[] rec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>            rec[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>            rec[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : rec) &#123;<br>            <span class="hljs-keyword">if</span>(num != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> !s.equals(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-变位词组"><a href="#33-变位词组" class="headerlink" title="33. 变位词组"></a>33. 变位词组</h2><p><img src="/img/leetcode/1680764799170-82b9b86c-6952-482b-8881-45c343749f48.png"></p><p>变位词有相同的属性，此时用map的key记录该属性，然后通过map来快速定位该词属于哪个变位词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String str : strs) &#123;<br>            <span class="hljs-type">char</span>[] cs = str.toCharArray();<br>            Arrays.sort(cs);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">newStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs);<br>            <span class="hljs-keyword">if</span>(map.containsKey(newStr)) &#123;<br>                List&lt;String&gt; list = map.get(newStr);<br>                list.add(str);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                list.add(str);<br>                res.add(list);<br>                map.put(newStr, list);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="34-外星语言是否排序"><a href="#34-外星语言是否排序" class="headerlink" title="34. 外星语言是否排序"></a>34. 外星语言是否排序</h2><p><img src="/img/leetcode/1680765360040-789250fe-d420-4a46-b2d0-db83ae74ce7b.png"></p><p>先用map或者数组记录字母对应的顺序，然后对字符串进行判断。</p><p>优先判断相同下标的大小关系，如果a更大return false，如果b更大return true，如果相同继续遍历，如果遍历到的下标大于等于b.length()，说明前面位置字符大小都相同，且a更长，此时return false。如果遍历过程中，没有return，说明在a的长度内字符均相同，且b的长度大于等于a，此时return true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAlienSorted</span><span class="hljs-params">(String[] words, String order)</span> &#123;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; order.length(); ++i) &#123;<br>            map.put(order.charAt(i), i);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(words.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; words.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(!checked(words[i - <span class="hljs-number">1</span>], words[i], map)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">checked</span><span class="hljs-params">(String a, String b, Map&lt;Character, Integer&gt; map)</span> &#123;<br> <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt;= b.length()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(map.get(a.charAt(i)) &lt; map.get(b.charAt(i))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(map.get(a.charAt(i)) &gt; map.get(b.charAt(i))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-最小时间差"><a href="#35-最小时间差" class="headerlink" title="35. 最小时间差"></a>35. 最小时间差</h2><p><img src="/img/leetcode/1680766424311-9ddc25cc-8a2e-4604-80a8-b48eba627a78.png"></p><p>首先对这些字符串进行排序，最小时间差肯定出现在相邻的字符串中</p><p>首先写一个getMinutes方法用于获取String类型代表的分钟，然后遍历得到最小的相邻差值</p><p>当timePoints的数量大于1440时，肯定有重复的，可以直接return 0</p><p>注意一个特殊情况，最小时刻和最大时刻的比较，此时也可能产生最小时间差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMinDifference</span><span class="hljs-params">(List&lt;String&gt; timePoints)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(timePoints.size() &gt; <span class="hljs-number">1440</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        Collections.sort(timePoints);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> getMinutes(timePoints.get(<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; timePoints.size(); ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> getMinutes(timePoints.get(i));<br>            res = Math.min(res, cur - pre);<br>            pre = cur;<br>        &#125;<br><br>        res = Math.min(getMinutes(timePoints.get(<span class="hljs-number">0</span>)) + <span class="hljs-number">1440</span> - pre, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getMinutes</span><span class="hljs-params">(String time)</span> &#123;<br>        <span class="hljs-keyword">return</span> ((time.charAt(<span class="hljs-number">0</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + time.charAt(<span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">60</span> + (time.charAt(<span class="hljs-number">3</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + time.charAt(<span class="hljs-number">4</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="36-后缀表达式"><a href="#36-后缀表达式" class="headerlink" title="36. 后缀表达式"></a>36. 后缀表达式</h2><p><img src="/img/leetcode/1684118521958-0237e8e8-6164-478e-a634-b6f94d56c457.png"></p><p>栈，用Deque和LinkedList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String token : tokens) &#123;<br>            <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;+&quot;</span>) || token.equals(<span class="hljs-string">&quot;-&quot;</span>) || token.equals(<span class="hljs-string">&quot;*&quot;</span>) || token.equals(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sec</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>                    res = first + sec;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>                    res = first - sec;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(token.equals(<span class="hljs-string">&quot;*&quot;</span>)) &#123;<br>                    res = first * sec;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = first / sec;<br>                &#125;<br>                stack.push(res);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(Integer.valueOf(token));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="37-小行星碰撞"><a href="#37-小行星碰撞" class="headerlink" title="37. 小行星碰撞"></a>37. 小行星碰撞</h2><p><img src="/img/leetcode/1684120709797-01069398-63d9-4cee-ab62-6796a86118c4.png"></p><p>当元素为正数时，直接push即可，不可能发生膨胀</p><p>当元素为负数时，用while循环，当stack为空或者前一个为负数时，直接push该元素并且break，此时不会膨碰撞；当前一个为正数时会碰撞，比较大小，如果正数更大，直接push(pre)并且break，不会再碰撞，如果一样大，同样break，如果负数更大，此时会继续while循环直到break</p><p>最后将stack中的元素赋值到res即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] asteroidCollision(<span class="hljs-type">int</span>[] asteroids) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(asteroids[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; asteroids.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> asteroids[i];<br>            <span class="hljs-keyword">if</span>(cur &gt; <span class="hljs-number">0</span>) &#123;<br>                stack.push(cur);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(stack.isEmpty() || stack.peek() &lt; <span class="hljs-number">0</span>) &#123;<br>                        stack.push(cur);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> stack.pop();<br>                        <span class="hljs-keyword">if</span>(pre &gt; -cur) &#123;<br>                            stack.push(pre);<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre == -cur) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;                              <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[stack.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> res.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            res[i] = stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="38-每日温度"><a href="#38-每日温度" class="headerlink" title="38. 每日温度"></a>38. 每日温度</h2><p><img src="/img/leetcode/1684121285328-3102343a-d1f0-441f-94dd-1ed017eb71b9.png"></p><p>单调栈，找到右边第一个大于的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temperatures.length; ++i) &#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> stack.pop();<br>                res[out] = i - out;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="39-直方图最大矩形面积（未做）"><a href="#39-直方图最大矩形面积（未做）" class="headerlink" title="39. 直方图最大矩形面积（未做）"></a>39. 直方图最大矩形面积（未做）</h2><p><img src="/img/leetcode/1684138001952-e0eead29-3140-4b0c-9d9d-db6a4cda7494.png"></p><h2 id="40-矩阵中最大的矩形（未做）"><a href="#40-矩阵中最大的矩形（未做）" class="headerlink" title="40. 矩阵中最大的矩形（未做）"></a>40. 矩阵中最大的矩形（未做）</h2><h2 id="41-滑动窗口的平均值"><a href="#41-滑动窗口的平均值" class="headerlink" title="41. 滑动窗口的平均值"></a>41. 滑动窗口的平均值</h2><p><img src="/img/leetcode/1684284897349-ac337cdb-5403-4434-b7c3-76a401baa0a3.png"></p><p>用队列记录窗口内的元素，并相应地进行删除和添加</p><p>用double sum记录窗口内的总和，而不必每次都迭代累加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovingAverage</span> &#123;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br><br>    Deque&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">double</span> sum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MovingAverage</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(list.size() &gt;= size) &#123;<br>            sum -= list.removeFirst();<br>        &#125;<br>        list.add(val);<br>        sum += val;<br>        <span class="hljs-keyword">return</span> sum / list.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-最近请求次数"><a href="#42-最近请求次数" class="headerlink" title="42. 最近请求次数"></a>42. 最近请求次数</h2><p><img src="/img/leetcode/1684286025323-ef18fee8-c672-4001-826e-71e255682d0e.png"></p><p>用队列保存3000ms内的请求，当ping进一个新的时间时，队列中的元素进行相应的删减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecentCounter</span> &#123;<br><br>    Queue&lt;Integer&gt; queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecentCounter</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ping</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peek() &lt; t - <span class="hljs-number">3000</span>) &#123;<br>            queue.poll();<br>        &#125;<br>        queue.offer(t);<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="43-往完全二叉树添加节点"><a href="#43-往完全二叉树添加节点" class="headerlink" title="43. 往完全二叉树添加节点"></a>43. 往完全二叉树添加节点</h2><p><img src="/img/leetcode/1684287106035-bfa7b13e-c085-4125-9705-f86df526d35e.png"></p><p>根据题意，只要通过层序遍历，依次将非完全节点加入队列即可，当每次新增一个节点的时候，新增节点的父节点是按照队列顺序的，需要注意的是，当新增节点是父节点的左子节点时，无需poll，此时该父节点还不完全；当新增节点是父节点的右子节点时，需要poll，该节点已完全。同时还需要向queue添加该新增节点，该节点也是不完全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBTInserter</span> &#123;<br><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    TreeNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CBTInserter</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        q.offer(root);<br>        <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>            <span class="hljs-keyword">if</span>(cur.left == <span class="hljs-literal">null</span> || cur.right == <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(cur);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) &#123;<br>                q.offer(cur.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                q.offer(cur.right);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> queue.peek();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(v);<br>        <span class="hljs-keyword">if</span>(parent.left == <span class="hljs-literal">null</span>) &#123;<br>            parent.left = cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent.right = cur;<br>            queue.poll();<br>        &#125;<br>        queue.offer(cur);<br>        <span class="hljs-keyword">return</span> parent.val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">get_root</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="44-二叉树每层的最大值"><a href="#44-二叉树每层的最大值" class="headerlink" title="44. 二叉树每层的最大值"></a>44. 二叉树每层的最大值</h2><p><img src="/img/leetcode/1684287596512-3fb5760d-17ba-476d-9e2a-08b1459e2a97.png"></p><p>用队列进行层序遍历即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestValues</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(root);  <br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                max = Math.max(max, cur.val);<br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                &#125;<br>            &#125;<br>            list.add(max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="45-二叉树最底层最左边的值"><a href="#45-二叉树最底层最左边的值" class="headerlink" title="45. 二叉树最底层最左边的值"></a>45. 二叉树最底层最左边的值</h2><p><img src="/img/leetcode/1684287622849-132c4761-4348-42b3-9219-287fee9d6e7b.png"></p><p>层序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;         <br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>                    res = cur.val;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-二叉树的右侧视图"><a href="#46-二叉树的右侧视图" class="headerlink" title="46. 二叉树的右侧视图"></a>46. 二叉树的右侧视图</h2><p><img src="/img/leetcode/1684288492827-de13d0bd-77a3-40e4-9273-f3cd023b50c4.png"></p><p>层序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(i == size - <span class="hljs-number">1</span>) &#123;<br>                    list.add(cur.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(cur.right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="47-二叉树剪枝"><a href="#47-二叉树剪枝" class="headerlink" title="47. 二叉树剪枝"></a>47. 二叉树剪枝</h2><p><img src="/img/leetcode/1684288697081-34ac9d37-88d8-408d-a86f-71125ce40e5e.png"></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag(root)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        root.left = pruneTree(root.left);<br>        root.right = pruneTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">flag</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> flag(root.left);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> flag(root.right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right &amp;&amp; root.val == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">pruneTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        root.left = pruneTree(root.left);<br>        root.right = pruneTree(root.right);<br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; root.val == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-序列化与反序列化二叉树"><a href="#48-序列化与反序列化二叉树" class="headerlink" title="48. 序列化与反序列化二叉树"></a>48. 序列化与反序列化二叉树</h2><p><img src="/img/leetcode/1684376895866-33f37fb5-b8d3-4a7d-92b6-9fa8013c07c5.png"></p><p>采用先序遍历的方式将二叉树序列化，节点之间用逗号隔开，为了确保二叉树反序列化的唯一性和确定性，需要将每个节点的空子节点也表示出来。需要注意第二个方法中，对字符串的操作都是重新创建一个字符串，所以递归的rserialize方法都要赋值给str</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> rserialize(root, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">rserialize</span><span class="hljs-params">(TreeNode root, String str)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            str += <span class="hljs-string">&quot;none,&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            str += String.valueOf(root.val) + <span class="hljs-string">&quot;,&quot;</span>;<br>            str = rserialize(root.left, str);<br>            str = rserialize(root.right, str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        String[] dataArray = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        List&lt;String&gt; dataList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(Arrays.asList(dataArray));<br>        <span class="hljs-keyword">return</span> rdeserialize(dataList);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">rdeserialize</span><span class="hljs-params">(List&lt;String&gt; data)</span> &#123;<br>        <span class="hljs-keyword">if</span>(data.get(<span class="hljs-number">0</span>).equals(<span class="hljs-string">&quot;none&quot;</span>)) &#123;<br>            data.remove(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.valueOf(data.get(<span class="hljs-number">0</span>)));<br>        data.remove(<span class="hljs-number">0</span>);<br>        root.left = rdeserialize(data);<br>        root.right = rdeserialize(data);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-从根节点到叶节点的路径数字之和"><a href="#49-从根节点到叶节点的路径数字之和" class="headerlink" title="49. 从根节点到叶节点的路径数字之和"></a>49. 从根节点到叶节点的路径数字之和</h2><p><img src="/img/leetcode/1684377551850-829f980b-7631-4a9f-881f-ece8c2c519e1.png"></p><p>dfs，将当前路径代表的大小作为递归函数的参数，每次递归一层，就乘以10.</p><p>当root节点为叶子节点时，将当前大小加到res中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> cur)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cur += root.val;     <br>        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            res += cur;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cur *= <span class="hljs-number">10</span>;<br>        dfs(root.left, cur);<br>        dfs(root.right, cur);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="50-向下的路径节点之和"><a href="#50-向下的路径节点之和" class="headerlink" title="50. 向下的路径节点之和"></a>50. 向下的路径节点之和</h2><p><img src="/img/leetcode/1684377813650-3d144e03-8e90-4f4d-94f3-bd57b76f2255.png"></p><p>由于任意的路径都是满足要求的，因此先用dfs遍历每个节点，然后对每个节点调用check方法，计算以该节点为root节点下满足条件的路径数。由于root.val可能比较大，因此用long类型来保存路径的总和</p><p>时间复杂度较高，重复遍历了很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        target = targetSum;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        check(root, <span class="hljs-number">0</span>);<br>        dfs(root.left);<br>        dfs(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> cur)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        cur += root.val;<br>        <span class="hljs-keyword">if</span>(cur == target) &#123;<br>            res++;<br>        &#125;<br>        check(root.left, cur);<br>        check(root.right, cur);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>前缀和记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 记录当前key（前缀和）出现value次数</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Integer&gt; preSumCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 目标值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = targetSum;<br>        <span class="hljs-comment">// 记录前缀和为0的次数为1</span><br>        preSumCount.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 前缀和使用Long，原因单节点最大值10的9次方，使用int会溢出</span><br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0L</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, Long currSum)</span>&#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 记录本层节点及以下节点中出现target的次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        currSum += node.val;<br><br>        <span class="hljs-comment">// 当前前缀和减去目标值 如果Map中有记录，则说明从某一点到当前节点的和等于目标值target</span><br>        res += preSumCount.getOrDefault(currSum - target, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 把当前前缀和加入Map</span><br>        preSumCount.put(currSum, preSumCount.getOrDefault(currSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归左右子树</span><br>        res += dfs(node.left, currSum);<br>        res += dfs(node.right, currSum);<br><br>        <span class="hljs-comment">// 恢复本层记录过的前缀和,恢复状态的原因是因为防止在不同分支上的节点满足target，但并不属于题目要求</span><br>        preSumCount.put(currSum, preSumCount.get(currSum) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-节点之和最大的路径（未做）"><a href="#51-节点之和最大的路径（未做）" class="headerlink" title="51. 节点之和最大的路径（未做）"></a>51. 节点之和最大的路径（未做）</h2><h2 id="52-展平二叉搜索树"><a href="#52-展平二叉搜索树" class="headerlink" title="52. 展平二叉搜索树"></a>52. 展平二叉搜索树</h2><p><img src="/img/leetcode/1686122270052-20c4fac4-e012-427f-a860-eb12176b7877.png"></p><p>中序遍历即可</p><p>注意创建一个新的TreeNode赋值给head.right，否则会出现环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TreeNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TreeNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">increasingBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> dummy.right;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root.val);<br>        head = head.right;<br>        dfs(root.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-二叉搜索树中的中序后继"><a href="#53-二叉搜索树中的中序后继" class="headerlink" title="53. 二叉搜索树中的中序后继"></a>53. 二叉搜索树中的中序后继</h2><p><img src="/img/leetcode/1686124208053-be172b23-0cc5-4b36-982c-11de20d5604c.png"></p><p>用链表存递增的TreeNode节点，并且在dfs过程中记录p所在的顺序，之后直接return list.get(order + 1)即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">inorderSuccessor</span><span class="hljs-params">(TreeNode root, TreeNode p)</span> &#123;<br>        dfs(root, p);<br>        <span class="hljs-keyword">if</span>(order == list.size() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list.get(order + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, TreeNode p)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left, p);<br>        ++cur;<br>        <span class="hljs-keyword">if</span>(root == p) &#123;<br>            order = cur;<br>        &#125;<br>        list.add(root);<br>        dfs(root.right, p);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-二叉搜索树中的中序后继"><a href="#54-二叉搜索树中的中序后继" class="headerlink" title="54. 二叉搜索树中的中序后继"></a>54. 二叉搜索树中的中序后继</h2><p><img src="/img/leetcode/1686124450552-dc07e56f-dcde-4c2a-8741-4592cbf23397.png"></p><p>调整遍历的顺序即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        convertBST(root.right);<br>        sum += root.val;<br>        root.val = sum;<br>        convertBST(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-二叉搜索树迭代器"><a href="#55-二叉搜索树迭代器" class="headerlink" title="55. 二叉搜索树迭代器"></a>55. 二叉搜索树迭代器</h2><p><img src="/img/leetcode/1686124730904-261f6f73-ee16-414b-bda0-81dc853fce81.png"></p><p>调用构造器的时候直接将二叉树转换成链表，用以后续判断即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br><br>    List&lt;Integer&gt; list;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        list.add(root.val);<br>        dfs(root.right);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        idx++;<br>        <span class="hljs-keyword">return</span> list.get(idx);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (idx + <span class="hljs-number">1</span>) &lt; list.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-二叉搜索树中两个节点之和"><a href="#56-二叉搜索树中两个节点之和" class="headerlink" title="56. 二叉搜索树中两个节点之和"></a>56. 二叉搜索树中两个节点之和</h2><p><img src="/img/leetcode/1688181023914-00983542-0ea2-47fc-97ae-ab4a59336fa2.png"></p><p>转换成链表后，双指针</p><p>遍历+哈希表也可以，类似二数之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findTarget</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = list.size() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.get(left) + list.get(right);<br>            <span class="hljs-keyword">if</span>(sum == k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; k) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        list.add(root.val);<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="57-值和下标之差都在给定的范围内"><a href="#57-值和下标之差都在给定的范围内" class="headerlink" title="57. 值和下标之差都在给定的范围内"></a>57. 值和下标之差都在给定的范围内</h2><p><img src="/img/leetcode/1688181860040-5c2b7b9a-824a-4111-adf5-07e2f10e220d.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>IT</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门</title>
    <link href="/2023/12/19/git%E5%85%A5%E9%97%A8/"/>
    <url>/2023/12/19/git%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>git config –global user.name “xxx”   配置全局用户名</p><p>git config –global user.email xxx.com   配置全局用户邮箱</p><p>git config –global –list   查看配置属性</p><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>（1）git init     &#x2F;    git init my-repo</p><p>（2）git clone xxxxxxxx.git</p><h4 id="工作区域和文件状态"><a href="#工作区域和文件状态" class="headerlink" title="工作区域和文件状态"></a>工作区域和文件状态</h4><p>工作区、暂存区、本地仓库</p><p>未跟踪、未修改、已修改、已暂存</p><h4 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h4><p>git status   查看仓库状态</p><p>git add test1.txt   将文件添加到暂存区</p><p>git commit -m “备注”</p><p>git add *.txt   将所有以txt结尾的文件添加到暂存区</p><p>git add .   将当前文件夹下所有文件添加到暂存区</p><p>git log   查看提交记录</p><p>git log –oneline   简洁版查看提交记录</p><p><img src="/%5Cimg%5Cgit%5C1.png"></p><h4 id="git-reset回退版本"><a href="#git-reset回退版本" class="headerlink" title="git reset回退版本"></a>git reset回退版本</h4><p>git reset –soft   回退到某一版本，工作区和暂存区保存</p><p>git reset –hard   回退到某一版本，工作区和暂存区都不保存</p><p>git reset –mixed   回退到某一版本，工作区保存，暂存区不保存</p><p>git reset –soft [commitID]   </p><p>git log –oneline   可以发现commit记录少了</p><p>ls   查看工作区内容</p><p>git ls-files   查看暂存区内容</p><p>git reset –hard HEAD^   HEAD^表示回退到上一个版本</p><p>git log –oneline</p><p>ls   查看工作区内容</p><p>git ls-files   查看暂存区内容</p><p>git reset HEAD^   默认采用mixed方式回滚</p><p>git log –oneline</p><p>ls   查看工作区内容</p><p>git ls-files   查看暂存区内容</p><p>git reflog   查看所有操作记录</p><p>git reset – hard [操作ID]   回退到相应版本，可以防止产生误操作</p><h4 id="git-diff查看差异"><a href="#git-diff查看差异" class="headerlink" title="git diff查看差异"></a>git diff查看差异</h4><p>git diff   默认查看工作区和暂存区的差异</p><p>git diff HEAD   比较工作区和版本库的内容差异</p><p>git diff –cached   比较暂存区和版本库的内容差异</p><p>git diff [commitID] [commitID]   比较两个版本间的差异</p><p>git diff [commitID] HEAD   </p><p>git diff HEAD~ HEAD   比较当前版本和上一个版本的差异</p><p>git diff HEAD^ HEAD   比较当前版本和上一个版本的差异</p><p>git diff HEAD~2 HEAD   比较当前版本和HEAD之前两个版本的差异</p><p>git diff HEAD~2 HEAD test.txt   比较该文件的差异内容</p><p><img src="/%5Cimg%5Cgit%5C2.png"></p><h4 id="git-rm删除文件"><a href="#git-rm删除文件" class="headerlink" title="git rm删除文件"></a>git rm删除文件</h4><p>rm test.txt   删除工作区文件</p><p>git rm test.txt   工作区和暂存区中的文件都会被删除</p><p><img src="/%5Cimg%5Cgit%5C3.png"></p><h4 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="headerlink" title=".gitignore忽略文件"></a>.gitignore忽略文件</h4><p>系统或者软件自动生成的文件</p><p>编译产生的中间文件和结果文件</p><p>运行时生成的日志文件、缓存文件、临时文件</p><p>涉及身份、密码、口令、密钥等敏感信息文件</p><p>echo access.log &gt; .gitignore   将access.log添加到.gitignore中，该文件会被忽略</p><p>echo *.log &gt;&gt; .gitignore   忽略所有log文件</p><p>如果有相应的文件在修改.gitignore文件前已经添加到了版本库，后续git会继续追踪该文件的状态</p><p>echo temp&#x2F; &gt;&gt; .gitignore   忽略temp文件夹下的文件</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/%5Cimg%5Cgit%5C4.png"></h4><h4 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h4><p>git remote add origin xxxxxx.git   添加远程仓库</p><p>git remote -v   查看远程仓库信息</p><p>git push -u origin main   将本地main分支与远程分支关联</p><p>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;   </p><p>git pull   默认将远程仓库中的main分支拉取到本地进行合并</p><p><img src="/%5Cimg%5Cgit%5C5.png"></p><h4 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h4><p>Github Desktop  </p><p>SourceTree</p><p>GitKraken</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>git branch   查看当前分支</p><p>git branch dev   创建新分支，名称为dev</p><p>git checkout dev   切换分支</p><p>git switch dev   切换分支</p><p>git checkout   可能会产生歧义，checkout可以用于恢复文件，当分支名与文件名一致时会优先切换分支</p><p>切换到main分支，执行git merge dev，将dev分支合并到main分支</p><p>git log – graph –oneline –decorate –all   展示分支合并过程</p><p>git branch -d dev   删除dev分支，合并后使用</p><p>git branch -D dev   强制删除dev分支</p><p><img src="/%5Cimg%5Cgit%5C6.png"></p><h4 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h4><p>git status   可以查看冲突文件</p><p>git diff   可以查看冲突具体内容</p><p>手动修改这个冲突文件之后再合并即可</p><p>git merge –abort   终止此次合并</p><h4 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h4><p>git中每个分支都有一个HEAD指针，rebase时会找到两个分支的最近公共父节点，然后rebase到指定的分支后面</p><p>git checkout -b dev 244d35   恢复dev分支到244d35状态</p><p>merge</p><p>优点：不会破坏原分支的提交历史，方便回溯查看</p><p>缺点：会产生额外的提交节点，分支图比较复杂</p><p>rebase</p><p>优点：不会新增额外的提交记录，形成线性历史，比较直观干净</p><p>缺点：会改变提交历史，改变当前分支branch out的节点，避免在共享分支使用</p><h4 id="分支管理和工作流模型"><a href="#分支管理和工作流模型" class="headerlink" title="分支管理和工作流模型"></a>分支管理和工作流模型</h4><p><img src="/%5Cimg%5Cgit%5C7.png"></p><p><img src="/%5Cimg%5Cgit%5C8.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2023/12/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/12/19/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo</p><p>echo hello </p><p>echo -n hello      -n表示不换行</p><p>name&#x3D;xx   echo $name     打印自定义参数</p><p>echo $?     打印上一次命令的状态码，0表示成功</p><p>echo ‘$name’    打印$name</p><p>echo “$name”   解析参数并打印</p><p>!!  打印上一条执行的命令，并打印执行结果</p><p>!n  执行以n开头的上一条命令，并打印执行结果</p><p>clear 清屏</p><p>echo “hello\nworld”   打印hello\nworld</p><p>echo -e “hello\nworld”   开启转义功能，hello和world间会换行</p><p>echo -e “\e[2;32;44mhello world\e[0m”   \e表示开启，2、32、44表示不同的样式，m表示结束，最后\e[0m表示后续打印的内容恢复默认设置</p><p><img src="/img/linux/1.png"></p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>pwd  当前目录</p><p>ll 显示当前目录中的文件</p><p>cd test&#x2F;  进入下一级目录</p><p>cd ..  返回上一级目录</p><p>cd &#x2F;home&#x2F;test&#x2F;testdir&#x2F;test1&#x2F;test2&#x2F;   进入指定目录</p><p>cd ~  回到home目录</p><p>cd -  回到上一次访问的目录</p><p>cd &#x2F;   回到根目录</p><p><img src="/img/linux/2.png"></p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find . -name “test1.txt”   .表示查找当前目录 -name表示按名称查找</p><p>find . -name “*.txt”  通配符查找所有txt文件</p><p>find . -iname “*.txt”   -iname忽略大小写</p><p>find . -type f   查找普通文件</p><p>find . -type d  查找目录文件</p><p>find . -type l   查找符号链接文件</p><p>find . -mmin +1  -m表示modify，修改文件  min表示分钟单位  +1表示一分钟之外</p><p>find . -mmin -1   -1表示一分钟内</p><p>find . -mtime -1  time表示天单位</p><p>find . -user test  查找test用户的文件</p><p>find . -group root  查找root组的文件</p><p><img src="/img/linux/3.png"></p><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>mkdir test1  创建test1目录</p><p>mkdir test1 test2 test3  创建多个目录</p><p>mkdir -p test4&#x2F;test5  创建目录以及子目录</p><p>mkdir -vp test&#x2F;subdir 创建目录以及子目录，并打印创建细节</p><p>mkdir -m 700 testdir  只有当前用户对该文件有rwx权限  7表示读写执行权限之和 0表示无权限  r对应4 w对应2 x对应1</p><p><img src="/img/linux/4.png"></p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>cp testfile.txt testfile1.txt</p><p>cp -v testfile.txt testdir  将文件复制到testdir目录下，并打印复制信息</p><p>cp -r testdir testdir2  复制目录文件</p><p>cp -i testfile.txt testdir  复制前会询问是否覆盖同名文件</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>cat testfile1.txt</p><p>cat -n testfile1.txt 显示内容以及行号</p><p>cat -b testfile1.txt 显示内容，只显示有文本内容的行数，空行不计入行号</p><p>cat -s testfile1.txt 显示内容，合并空行</p><p>cat -E testfile1.txt 显示内容，每行内容末尾加$符号</p><p>cat -T testfile1.txt 显示内容，制表符会转换成^I，帮助判断是空格还是制表符</p><p>cat -A testfile1.txt 同时实现-E和-T的效果</p><p>cat testfile1.txt testfile2.txt 同时查看多个文件的内容</p><p><img src="/img/linux/5.png"></p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>rm testfile.txt</p><p>rm -r test1 删除目录文件</p><p>rm -i -r test2 删除前询问是否确认删除</p><p><img src="/img/linux/6.png"></p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>wc test.txt  打印文本中的行数、单词数、字节数以及文件名</p><p>wc -l test.txt  打印行数<br>wc -w test.txt   打印单词书</p><p>wc -c test.txt   打印字节数</p><p>wc -m test.txt   打印字符数</p><p> <img src="/img/linux/7.png"></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar -cf testdir.tar testdir   压缩</p><p>tar -xf testdir.tar   解压</p><p>tar -zcf testdir.tar.gz testdir  不同算法进行压缩</p><p>tar -zxf testdir.tar.gz  不同算法进行解压</p><p>tar -zxvf testdir.tar.gz   打印解压信息</p><p><img src="/img/linux/8.png"></p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>tail test.txt  </p><p>tail -n 5 test.txt   打印倒数五行</p><p>tail -n +5 test.txt   从第五行打印到最后一行</p><p>tail -f test.txt   动态更新打印文件中新增的内容</p><p>tail -F test.txt   文件丢失了，也会持续地搜索相应文件里的内容</p><p>head test.txt  从前往后打印，默认十行</p><p>head -n 5 test.txt   打印前五行</p><p>head -n -5  从前打印到倒数第五行</p><p><img src="/img/linux/9.png"></p><h2 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h2><p>vim test1.txt   创建新文件，按i进入编辑模式，按ESC回到一般模式，按：进入底线命令行模式</p><p>:set number   设置行号</p><p>:set nonumber   取消行号</p><p>:wq   w保存，q退出</p><p>一般模式下，ctrl+F用于翻一页，ctrl+B用于回翻一页，ctrl+U回翻半页，ctrl+D，翻半页</p><p>yy复制一行，P在光标上面复制，p在光标下面复制，dd删除</p><p>在相应指令前加数字，代表移动n行&#x2F;复制n行</p><p>gg跳到文本首部，G跳到文本尾部</p><p>&#x2F;hello   向下搜索hello</p><p>?hello   向上搜索hello</p><p>n表示当前方向的下一个，N表示当前方向相反的下一个</p><p><img src="/img/linux/10.png"></p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 1 test.txt   查找包含指定文本的相关内容，区分大小写</p><p>grep -i hello test.txt   不区分大小写</p><p>grep -w hello test.txt   精确匹配</p><p>grep -e hello -e today test.txt   多个查询条件</p><p>grep -n hello test.txt   查找相关内容，并显示它的行号</p><p>grep -v hello test.txt   反向查找，查找不包含hello的内容</p><p>grep -r hello testdir&#x2F;   查找文件夹中包含指定文本的文件，以及相关文本内容</p><p>grep -lr hello testdir&#x2F;    只打印相关文件名</p><p>grep -E ‘hello|today’ test.txt   启用正则表达式</p><p><img src="/img/linux/11.png"></p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed -e ‘1i\hello’ test.txt   -e表示表达式，1i\hello表示在第一行前插入hello，不指定行数默认表示对每一行进行操作</p><p>并不会直接生效，用-i表示直接生效   sed -ie ‘1i\hello’ test.txt，命令执行后多了一个.txte文件，是原来的备份文件</p><p>sed -i ‘1i\hello’ test.txt   不会生成备份文件</p><p>sed -e ‘1a\hello’ test.txt   a表示在相应行后面新增，append</p><p>sed -e ‘4d’ test.txt   d表示删除行，delete</p><p>sed -e ‘1c\copy’ test.txt   c表示全局覆盖，copy</p><p>sed -e ‘s&#x2F;1&#x2F;sss’ test.txt   s表示局部替换，将1替换为sss</p><p>sed -e ‘s&#x2F;1&#x2F;sss&#x2F;g’ test.txt   g表示全局地进行局部替换，会执行多次局部替换</p><p>sed -e ‘1p’ test.txt   打印第一行</p><p>sed -n ‘1p’ test.txt   -n表示不打印缓冲区内容，只打印执行结果</p><p>多个-e写在一起表示多个脚本同时执行</p><p>sed -f test.sh test.txt   将多个脚本写入test.sh，通过-f读取文本执行多个脚本</p><p><img src="/img/linux/12.png"></p><h2 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h2><p>将前一个命令的标准输出作为后一个命令的标准输入，只会传递标准输出，不会传递标准错误输出</p><p><img src="/img/linux/13.png" alt="mg"></p><h2 id=""><a href="#" class="headerlink" title="&gt;"></a>&gt;</h2><p>cat test1.txt | grep hello &gt; test.log  将test1.txt中hello相关的内容写入test.log，test.log如果存在就会覆盖，如果不存在先新建再写入</p><p>grep hello test1.txt &gt;&gt; test.log   追加写入</p><p>&gt;只会重定向标准输出，不会重定向标准错误输出。&gt;是1&gt;的简写。</p><p>cat test2.txt 2&gt; test.log   重定向标准错误输出</p><p>cat test1.txt test2.txt &gt; test.log 2&gt;&amp; 1  重定向标准输出和标准错误输出</p><p><img src="/img/linux/14.png"></p><h2 id="-1"><a href="#-1" class="headerlink" title="&lt;"></a>&lt;</h2><p>cat后面什么都不跟，表示将标准输入转换成标准输出</p><p>cat &lt; test.txt  将test.txt中的文本作为标准输入，cat命令将其转换为标准输出</p><p>cat &lt;&lt; EOF   多次输入，最后结束时同样输入EOF结束输入。这个EOF可以由自己定义，前后保持一致即可</p><p>cat &gt; test2.txt &lt;&lt; EOF   创建test2.txt，并写入数据</p><p><img src="/img/linux/15.png"></p><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>printf “$name\n”</p><p>printf “\e[5;31m$name\n\e[0m”</p><p>%-3s，三个字符长度的字符串，左对齐。-表示左对齐，没有表示右对齐。3表示长度。s表示数据类型。</p><p>printf “%-10s\n %10s\n” “hello” “world”   hello左对齐，world右对齐，长度没满足设置的话为空</p><p><img src="/img/linux/16.png"></p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>每一行称为record，每一个字符串称为field</p><p>awk ‘{print $1}’ test.txt   打印文件的第一列</p><p>awk ‘{print $NF}’ test.txt   打印文件的最后一列</p><p>字段分隔符FS、记录分隔符RS</p><p>输出字段分隔符OFS、输出记录分割符ORS</p><p>awk ‘{OFS&#x3D;”#”; $1&#x3D;$1; print $0}’ test.txt   将字段分隔符改为#，$1&#x3D;$1表示刷新，print $0 表示打印整行数据</p><p>awk -v OFS&#x3D;”#” ‘{$1&#x3D;$1; print $0}’ test.txt   </p><p>awk ‘{printf “%-3s %2d %2d %2d\n”, $1,$2,$3,$4}’ test.txt   格式化打印</p><p>awk ‘{if(NR&#x3D;&#x3D;3){print $0} else{print “不是第三行”}}’ test.txt    if-else语句</p><p>awk ‘NR&#x3D;&#x3D;3{print $0}’ test.txt   模式+操作，模式用于匹配，操作用于执行相关逻辑</p><p>awk ‘NR&#x3D;&#x3D;1,NR&#x3D;&#x3D;3{print $0}’ test.txt  打印1~3行</p><p>awk ‘NR&#x3D;&#x3D;1||NR&#x3D;&#x3D;3{print $0}’ test.txt   打印第一行和第三行</p><p>awk ‘&#x2F;1&#x2F;{print $0}’ test.txt   模式用正则表达式书写，打印以1开头的记录</p><p>awk ‘&#x2F;1&#x2F; {print index($1, “1”)}’ test.txt   index函数，打印以1开头的记录的第一个字段中1字符的索引位置</p><p>awk ‘&#x2F;1&#x2F; {print length($1)}’ test.txt   length函数，打印以1开头的记录的第一个字段的长度</p><p>awk ‘&#x2F;1&#x2F;‘ test.txt   只保留模式匹配，默认打印整行</p><p>awk ‘{print $1}’ test.txt   只保留操作</p><p>awk ‘BEGIN{OFS&#x3D;”#”} {$1&#x3D;$1;print $0}’ test.txt   BEGIN语句</p><p>awk ‘BEGIN{printf “%3s %3s %3s”, “语文”,”数学”,”英语”} {printf “%3d %3d %3d”, $1, $2,  $3}’ test.txt</p><p>awk ‘BEGIN{printf “%3s %3s %3s”, “语文”,”数学”,”英语”} {printf “%3d %3d %3d”, $1, $2,  $3}’ test.txt</p><p>awk ‘BEGIN{printf “%3s %3s %3s”, “语文”,”数学”,”英语”} {printf “%3d %3d %3d”, $1, $2,  $3} END{printf “%3s%d%s”, “一共有”,NR,”行”}’ test.txt   END语句</p><p>awk ‘BEGIN{print “姓名”} NR&#x3D;&#x3D;2 {print $1} END{print “test”}’ test.txt</p><p>awk -f awk.sh test.txt   支持通过文件输入命令</p><p><img src="/img/linux/17.png"></p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>touch test.txt   创建空文件</p><p>touch test1.txt test2.txt   批量创建空文件</p><p>touch -c test3.txt   -c不会创建空文件</p><p>stat test.txt   查看文件属性</p><p>touch test.txt   将文件的access time和modify time改为当前时间；由于access time和modify time也属于change范围内的一种，所以change time也会改为当前时间</p><p>touch -d 20210102 test.txt   将access和modify time改为20210102，change time改为修改的当前时间</p><p>touch -t 202102021918.33 test.txt   -t对时间有格式要求</p><p>touch -r test1.txt test.txt   根据test1.txt的时间设置test.txt的时间</p><p>touch -a test.txt   修改access time</p><p>touch -m test.txt   修改modify time</p><p><img src="/img/linux/18.png"></p><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>一般与管道符号连用，将标准输入转换为参数</p><p>echo “hello world” | xargs echo</p><p>echo “hello world” | xargs -n 1   一次传递一个参数，不写命令时默认为echo</p><p>echo “hello%world” | xargs -d “%”   按照%进行分隔解析</p><p>echo -n “hello%world” | xargs -d “%”   按照%进行分隔解析，不打印换行</p><p>echo -n “hello world” | xargs -p   在执行前进行询问，是否执行该命令</p><p>echo -n “hello world” | xargs -t   直接执行命令，并且打印执行了什么命令</p><p>echo -n “hello world” | xargs -I {} echo {}</p><p>echo | xargs echo   仍然会执行该命令，尽管参数为空</p><p>echo | xargs -r echo   参数为空，不执行</p><p>cat test.txt | xargs echo   将test.txt中的文本转换成一行输出，并且\或’’等会删除</p><p>cat test.txt | xargs -n 2 echo   将test.txt中的文本输出，每行两个参数</p><p>cat test.txt | xargs touch   批量创建文件</p><p>cat test.txt | xargs rm   批量删除</p><p><img src="/img/linux/19.png"></p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>ls   查看当前目录下的文件</p><p>ls -a   查看当前目录下的所有文件</p><p>ls -A   查看当前目录下除了.和..以外的所有文件</p><p>ls -l   用一行的内容输出一个文件的相关信息</p><p>ls -R   递归形式列出当前目录和子目录下的文件</p><p>ls -S   按照大小进行排序，从大到小</p><p>ls -t   按最后修改时间排序</p><p><img src="/img/linux/20.png"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>上下键记录了此前执行的命令</p><p>t + pageUp，搜索以t开头的命令</p><p>ctrl + a，移动到行首</p><p>ctrl + e，移动到行尾</p><p>ctrl + w，删除光标前的一个单词</p><p>ctrl + u，删除光标前所有内容</p><p>ctrl + k，删除光标后所有内容</p><p>ctrl + y，复原删除的内容</p><p>ctrl + l，清屏</p><p>tab键用于补全命令，连按两下显示所有可能的命令</p><p>ctrl + r，搜索，右键将命令显示，enter直接执行</p><p><img src="/img/linux/21.png"></p><h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><p>硬链接，指向相同的inodeID</p><p>ln test.txt test3.txt   给test.txt创建一个新的硬链接，名称为test3.txt</p><p>ls -il    -i查找文件对应的inodeID   硬链接的两个文件对应的inodeID一致</p><p>软链接，指向文件名</p><p>ln -s test.txt test4.txt   给test.txt创建一个软链接，名称为test4.txt</p><p>ln &#x2F;home&#x2F;test&#x2F;test &#x2F;home&#x2F;test&#x2F;testdir&#x2F;hardlinktest    在不同的目录下创建硬链接</p><p><img src="/img/linux/22.png"></p><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>pwd   打印当前目录</p><p>pwd -L   打印逻辑路径</p><p>pwd -P   打印物理路径</p><p>当存在软链接时，逻辑路径和物理路径有所不同，物理路径是指向的那个目录所在的实际路径</p><p><img src="/img/linux/23.png"></p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>mv test4.txt test&#x2F;   将test4.txt移动到test&#x2F;目录下</p><p>mv test4.txt test&#x2F;movetest.txt    移动，并且重命名</p><p>mv test2.txt movetest.txt   不移动，只重命名</p><p>mv -v test.txt test&#x2F;   打印详细移动信息</p><p>mv -vb test.txt test&#x2F;   -b当目标路径下文件与要移动的文件名相同是，原文件会进行备份</p><p>mv -fv test.txt test&#x2F;   强制覆盖</p><p>mv -iv test.txt test&#x2F;   覆盖前进行询问</p><p>mv -nv test.txt test&#x2F;   如果有重名，不覆盖</p><p><img src="/img/linux/24.png"></p><h2 id="用户及权限管理"><a href="#用户及权限管理" class="headerlink" title="用户及权限管理"></a>用户及权限管理</h2><p>root、系统用户、普通用户</p><p>cat &#x2F;etc&#x2F;passwd   查看服务器用户信息</p><p>cat &#x2F;etc&#x2F;shadow   查看密码信息</p><p>cat &#x2F;etc&#x2F;login.defs   登录配置项</p><p>cat &#x2F;etc&#x2F;default&#x2F;useradd   useradd命令下的配置</p><p>cat &#x2F;etc&#x2F;group   组相关的信息</p><p>cat &#x2F;etc&#x2F;gshadow   组相关密码信息</p><p><img src="/img/linux/25.png"></p><p><img src="/img/linux/26.png"></p><p><img src="/img/linux/27.png"></p><p><img src="/img/linux/28.png"></p><p><img src="/img/linux/29.png"></p><h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>useradd test1   新增用户</p><p>cat &#x2F;etc&#x2F;passwd | grep test1   查找创建用户的相关信息</p><p>passwd test1   设置&#x2F;修改密码</p><p>useradd -p [password] test2   创建用户同时设置密码</p><p>openssl passwd -1 “123456”   -1表示采用md5加密算法加密“123456”</p><p>useradd -b &#x2F;tmp test3   -b创建用户时设置他所在的base目录</p><p>useradd -d &#x2F;tmp&#x2F;tt4 test4   -d创建用户时设置他所在的home目录</p><p>useradd -c “测试用户” test5   -c创建用户时添加备注</p><p>useradd -G root,ceph test6   -G创建用户时修改附属组信息</p><p>useradd -s &#x2F;bin&#x2F;sh test7   -s创建用户时修改他的命令目录</p><p>useradd -D   -D查看创建用户时的默认信息</p><p>useradd -D -b &#x2F;tmp   修改创建用户时的默认设置，-b表示修改base目录</p><p>useradd -r test8   创建系统用户</p><p><img src="/img/linux/30.png"></p><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>usermod -c “测试用户” test1   创建用户之后添加备注信息</p><p>usermod -G bin test1   会删除用户原附属组的信息，并新增当前附属组</p><p>usermod -aG bin test1   只增加，不删除，-a表示append</p><p>usermod -l test3 test2   将test2的用户名改为test3，但是home目录不变</p><p>usermod -p 55555 test1   修改test1用户的密码</p><p><img src="/img/linux/31.png"></p><h2 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h2><p>userdel test1   删除用户，但home目录和接受邮件的目录不会被删除</p><p>userdel -r test1   删除用户以及相关文件</p><p><img src="/img/linux/32.png"></p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><p>groupadd test   新增组</p><p>groupadd -g 1010 test1   新增组并设置组id</p><p>groupdel test1   删除组</p><p>groupmod -g 1111 test1   修改组的id</p><p>groupmod -n test2 test1   修改test1组名称为test2</p><p><img src="/img/linux/33.png"></p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>chown ceph test1.txt   修改test1.txt的属主信息</p><p>chown ceph:root test1.txt   修改test1.txt的属主和属组信息</p><p>chown ceph test   修改test文件夹的属主信息，内部文件信息保持不变</p><p>chown -R ceph test   修改test文件夹的属主信息，并递归地修改内部文件的属主信息</p><p><img src="/img/linux/34.png"></p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p><img src="/img/linux/35.png"></p><p>chmod u+rw test1.txt   当前用户对test1.txt有读写权限</p><p>chmod 760 test1.txt   当前用户又读写执行权限，同组用户有读写权限，其他用户无权限</p><p>chmod g-rw test1.txt   解除同组用户的读写权限</p><p>chmod o+w test   其他用户对该目录添加写权限</p><p>chmod 777 -R test   给test目录下所有文件设置权限</p><p>chmod -cR 760 test   -c显示修改信息</p><p>chmod -vR 760 test   -v无论权限是否修改，都会打印相关信息</p><p><img src="/img/linux/36.png"></p><h2 id="su"><a href="#su" class="headerlink" title="su"></a>su</h2><p>su test1   将用户切换成test1</p><p>su -c “ls” root   切换用户并执行相关命令</p><p>su -l test1   切换用户，并且目录换成当前用户的home目录</p><p><img src="/img/linux/37.png"></p><h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>visudo   编辑etc&#x2F;sudoers文件内容；也可以将用户添加到相应的组里，这样也能执行sudo命令；也可以指定当前用户能执行的命令，而不是可以执行所有命令</p><p>sudo -l   查询当前用户可以执行的一些命令</p><p>sudo -k   此前输入的密码有效期立马过期</p><p>sudo -v   延长有效期</p><p>sudo -u ceph [命令]   使用ceph用户执行命令；没有时，默认使用root用户</p><h2 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h2><p>hostname   查看主机名</p><p>hostname test1   修改主机名，只是临时的，重启后仍然是原来的主机名</p><p>hostnamectl set-hostname vm1   永久修改hostname</p><p><img src="/img/linux/38.png"></p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>alias ct&#x3D;’cat &#x2F;etc&#x2F;passwd | grep test’   暂时设置，操作系统重启后消失</p><p>alias -p   打印所有别名</p><p>vim ~&#x2F;.bashrc   永久修改</p><p>unalias ct   取消别名</p><p><img src="/img/linux/39.png"></p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut -b 1 test1.txt   截取文件中每一行的第一个字节</p><p>cut -b 1-3 test1.txt   截取第1~3个字节</p><p>cut -b 1- test1.txt   截取第1~最后一个字节</p><p>cut -b -3 test1.txt   截取第1~3个字节</p><p>cut -b 1,3,4 test1.txt   截取第1，3，4个字节</p><p>cut -nb 1 test1.txt   针对汉字，不会只截取一个字节</p><p>cut -c 1 test1.txt   截取一个字符</p><p>cut -d “ “ -f 1 test.txt   -d表示以” “为分隔符，-f表示字段</p><p>cut -d “ “ -f 1 -s test.txt   不包含分隔符的不再打印</p><p>cut -d “ “ -f 1- -s –output-delimiter “$$$”   设置输出分隔符</p><p>cat &#x2F;etc&#x2F;passwd | grep test | cut -d “:” -f 1</p><p><img src="/img/linux/40.png"></p><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>echo ‘abcabc’ | tr ‘a’ ‘z’   将标准输入中的a转换为z</p><p>echo ‘abcabc’ | tr ‘ab’ ‘z’   按单字符逻辑进行替换，ab替换为zz</p><p>echo ‘abcabc’ | tr -t ‘ab’ ‘z’   强制匹配，ab替换为z</p><p>echo ‘abcabc’ | tr ‘\n’ ‘\t’   支持转义</p><p>echo ‘abcabc’ | tr ‘a-z’ ‘A-Z’   支持字符集</p><p>echo ‘abc123’ | tr ‘0-9’ ‘A-Z’   支持字符集</p><p>echo ‘abc123’ | tr ‘[:lower:]’ ‘[:upper:]’   小写字母转换成大写字母</p><p>echo ‘abc123’ | tr ‘[:alpha:]’ ‘-‘   将所有字母转换为-</p><p>echo ‘abc123’ | tr ‘[:digit:]’ ‘-‘   将所有数字转换为-</p><p>echo ‘abc123’ | tr -d ‘[:digit:]’   删除数字</p><p>echo ‘abc123’ | tr -cd ‘[:digit:]’   保留数字</p><p>echo ‘aaaaab’ | tr -s ‘a’   压缩字母a</p><p><img src="/img/linux/41.png"></p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>cat &#x2F;etc&#x2F;passwd | tail -n 10 | sort</p><p>cat &#x2F;etc&#x2F;passwd | tail -n 10 | sort -r   -r字典序降序排列</p><p>cat &#x2F;etc&#x2F;passwd | tail -n 10 | sort -t “:” -k 3   -t分隔符，-k对第几列进行排序</p><p>cat &#x2F;etc&#x2F;passwd | tail -n 10 | sort -t “:” -k 3 -n   -n数值大小排序</p><p>ls -lh | sort -k 5 -h   -h将相应的单位转换为数值后排序，如K这个单位</p><p>cat &#x2F;etc&#x2F;passwd | tail -n 10 | sort -t “:” -k 3 -n -o test.txt   -o将标准输出保存到test.txt</p><p>sort test.txt   不会修改原文件中的内容，空白行会排在最前面</p><p>sort -u test.txt   -u去重</p><p>sort -c test.txt   查看文件是否有序</p><p>sort -C test.txt   不会输出是否有序的结果，需要通过状态码查看echo $?</p><p><img src="/img/linux/42.png"></p><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>uniq test.txt   原文本不变</p><p>uniq test.txt test2.txt   将去重后的文件保存为test2.txt</p><p>uniq -c test.txt   打印不同的行出现的次数</p><p>uniq -d test.txt   只打印重复的行</p><p>uniq -u test.txt   只打印不重复的行</p><p>uniq -i test.txt   忽略大小写去重</p><p>uniq  -f 1 test.txt   跳过每一行的第一列进行去重处理</p><p>uniq -s 1 test.txt   跳过每一行的第一个字符进行去重处理</p><p>uniq -w 1 test.txt   按每一行的第一个字符进行去重 </p><p><img src="/img/linux/43.png"></p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch ‘tail test.txt’ </p><p>watch -n 5 ‘tail test.txt’   -n修改时间间隔</p><p>watch -n 5 -d ‘tail test.txt’   -d高亮显示修改前后不同的内容</p><p>watch -n 5 -t ‘tail test.txt’   -t取消标题行</p><p>watch -g ‘tail test.txt’   发生变化后直接退出，不再监控</p><p>watch -e ‘tail test.txt’   命令执行失败后直接退出，例如删除test.txt后命令会执行失败</p><p><img src="/img/linux/44.png"></p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top  有四个窗口可以查看，g+(1~4)用于选择跳转哪个窗口</p><p>1默认窗口   2Job窗口   3内存窗口   4User窗口</p><p>A   同时展示四个窗口</p><p>a   往下一个窗口</p><p>w   往上一个窗口</p><p><img src="/img/linux/45.png"></p><p><img src="/img/linux/46.png"></p><p><img src="/img/linux/47.png"></p><p>top中的交互式命令</p><p>h — 跳转到帮助文档，记录了所有交互式命令</p><p>Z — 颜色配置 </p><p>E — 循环切换概览区域内存单位</p><p>e — 循环切换表中的内存单位</p><p>其余命令看帮助文档即可</p><p><img src="/img/linux/48.png"></p><p><img src="/img/linux/49.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
